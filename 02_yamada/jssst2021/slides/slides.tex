\documentclass[dvipdfmx,11pt]{beamer}

%全体設定
%\AtBeginDvi{\special{pdf:tounicode 90ms-RKSJ-UCS2}}
\input{macro}

\title[ASPに基づく組合せ遷移ソルバーの実装方式に関する考察]{解集合プログラミングに基づく\\組合せ遷移ソルバーの実装方式に関する考察}
\author[山田 悠也，湊 真一，番原 睦則]{山田 悠也$^1$，湊 真一$^2$，番原 睦則$^1$}
\date{日本ソフトウェア科学会第38回大会}
\institute{1.名古屋大学 大学院情報学研究科 \\ 2.京都大学 大学院情報学研究科}

%% テンプレ 
\begin{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% タイトル
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{}
\end{frame}

\end{comment}

%###########################################################
%# 本文 ####################################################
%###########################################################
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% タイトル 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{}
  \titlepage
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 組合せ遷移問題
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{組合せ遷移問題(Combinatorial Reconfiguration Problems)}

  \begin{alertblock}{}
    \alert{\bf 組合せ遷移問題}とは，
    基となる組合せ問題とその2つの実行可能解が与えられたとき，一方の実行可能解
    から他方の実行可能解へ，遷移制約を満たしつつ，
    実行可能解のみを経由して到達できるかを判定する問題．
  \end{alertblock}

  \begin{itemize}
    %\item 既存の組合せ問題の多くを組合せ遷移問題に拡張できる．
    \item 基となる問題が NP 完全であるとき，その遷移問題の多くは
      \alert{PSPACE完全}であることが知られている．
    \item 代表的な組合せ遷移問題
      \begin{itemize}
      \item 命題論理の充足可能性判定問題(SAT)の遷移問題~[Gopalan+ '09]
      \item 集合被覆問題の遷移問題~[Ito+ '11]
      \item グラフ点彩色問題の遷移問題~[Paul Bonsma+ '09]
      \end{itemize}
    \item 持続可能なシステムへの実用的応用が期待されている．
    \item 理論的な基盤が整備されつつある一方で，
          組合せ遷移問題の\alert{汎用的なソルバーの実践的な研究開発は始まったばかりである}．
  \end{itemize}
  %\begin{alertblock}{}%\centering
  %  本研究では，グラフ点彩色問題の遷移問題(\alert{$k$彩色遷移問
  %  題})をインスタンスとする．
  %\end{alertblock}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% k彩色遷移問題
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{$k$彩色遷移問題}

  \begin{block}{$k$彩色遷移問題}
    \begin{itemize}
    \item 問題の入力として，グラフ点彩色問題とその二つの実行可能解
          (\structure{スタート状態}と\structure{ゴール状態})が与えられる．
    \item 遷移制約は「\structure{各遷移で色が変化する頂点はただ一つのみ}」である．
    \end{itemize}
  \end{block}

  \begin{exampleblock}{$k$彩色遷移問題の例}
    \begin{columns}
      \begin{column}{0.3\textwidth}
        \centering
        \input{tikz/graph0.tex}
%        ステップ0($=\alpha$)
      \end{column}
      \begin{column}{0.05\textwidth}
        \textbf{$\longrightarrow$}
      \end{column}
      \begin{column}[]{0.3\textwidth}
        \centering
        \input{tikz/graph1.tex}
%        ステップ1
      \end{column}
      \begin{column}{0.05\textwidth}
        \textbf{$\longrightarrow$}
      \end{column}
      \begin{column}{0.3\textwidth}
        \centering
        \input{tikz/graph2.tex}
%        ステップ2($=\beta$)
      \end{column}
    \end{columns}
  \end{exampleblock}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ASP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{解集合プログラミング(Answer Set Programming; ASP)}

  \begin{itemize}
    \item ASP の言語は一般拡張選言プログラムに基づく．
    \item ASPシステムは安定モデル理論~[Gelfond and Lifschitz '88] に基づく
          解集合を計算するシステムである．
    \item 近年，SAT技術の応用により高速なASPシステムが実現し, 
          システム検証やプランニングなどの様々な分野での実用的応用が拡大している．
  \end{itemize}

  \begin{alertblock}{組合せ遷移問題に対してASPを用いる利点}
    \begin{itemize}
      \item ASPの高い表現力により，記号制約を簡潔に記述できる．
      \item インクリメンタルASP解法により，同様の探索失敗を避けるために獲得した学習節を保持することで，遷移問題に対する効率的な解探索が可能である．
    \end{itemize}
  \end{alertblock}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ASP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{ASP の基本的な構文}

  一般拡張選言プログラムのサブクラスである
  論理プログラム\footnote{標準論理プログラムを指す．}について説明する．

  \begin{itemize}
    \item \structure{論理プログラム}とは，以下の形式の
          \structure{ルール}の有限集合である．
          \begin{block}{}
            \centering
            $a_0$ \code{:-} $a_1, \dots, a_m,$ \code{not} $a_{m+1}, \dots,$ \code{not} $a_{n}$
          \end{block}
          \begin{itemize}
            \item $0 \le m \le n$であり，各$a_i$はアトム，\code{not}はデフォルトの否定，
                  ``\code{,}''は連言を表す．\code{:-}の左側をヘッド，右側をボディと呼ぶ．
            \item 直感的な意味は，「$a_1, \dots, a_m,$が成り立ち，$a_{m+1}, \dots, a_{n}$
                  が成り立たないのであれば$a_{0}$は成り立つ」である．
          \end{itemize}       
    \item ボディが空のルールを\structure{ファクト}と呼び，\code{:-}を省略できる．
          \begin{itemize}
            \item ヘッドが常に成り立つことを意味する．
          \end{itemize}
    \item ヘッドが空のルールを\structure{一貫性制約}と呼ぶ．例えば，
          \code{:-} $a_1,$ \code{not} $a_2$は，$a_1$が成り立つなら$a_2$が
          成り立つことを意味する．
  \end{itemize}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ASP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{ASP の拡張構文}

  \begin{itemize}
    \item \structure{選択子}は
          \begin{center}
            \code{\{} $a_0$ \code{;} $\dots$ \code{;} $a_{m}$ \code{\}}
          \end{center}
          の形式で記述される．
          \begin{itemize}
            \item アトムの集合$\{ a_0, \dots, a_m\}$の任意の部分集合が成り立つことを
                  意味する．
          \end{itemize}
    \item \structure{個数制約}は
          \begin{center}
            $lb$ \code{\{} $a_0$ \code{;} $\dots$ \code{;} $a_{m}$ \code{\}} $ub$
          \end{center}
          の形式で記述される．
          \begin{itemize}
            \item $a_0, \dots, a_m$のうち，$lb$個以上$ub$個以下が成り立つことを意味する．
          \end{itemize}
  \end{itemize}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 研究目的
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{研究目的}

  \begin{alertblock}{目的}
    ASP技術を活用し，大規模な組合せ遷移問題を効率よく解くシステムを実現する．
  \end{alertblock}

  \begin{block}{研究内容}
    \begin{enumerate}
    \item 組合せ遷移問題に対して，有界組合せ遷移を提案した．
    \item 有界組合せ遷移に基づき組合せ遷移問題を解く2つのソルバーを提案した．
    \item $k$彩色遷移問題を解く2種類の符号化を提案した．
    \item 独自に作成したベンチマーク問題を用い，ソルバー及び符号化の評価実験を行った．
    \end{enumerate}
  \end{block}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 有界組合せ遷移
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{有界組合せ遷移}

  \begin{alertblock}{}
    \alert{\bf 有界組合せ遷移}とは，
    組合せ遷移問題に対してステップ長$\ell$を
    与え到達可能性を検査するものである．
  \end{alertblock}

  \begin{itemize}
    \item 与えられた組合せ遷移問題に対して，
          \structure{長さ$\ell$の遷移系列が存在するか}を解く．
    \item 制限された長さで系列が存在しない場合，長さを1増加させ
          再度問題を解く．
    \item 有界組合せ遷移は到達可能な遷移系列を探すのみで，
          到達不能の証明は行わない．
          \begin{itemize}
            \item ただし，適切な$\ell$の上限値を与えることで到達不能の
                  証明も行える．
          \end{itemize}
    \item 仮に遷移系列が存在する場合，得られた遷移系列は組合せ遷移問題の解の中で
          最短のものである．
  \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 有界組合せ遷移
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{有界組合せ遷移の例}

  \begin{enumerate}
    \item $\ell = 0$とする．
    \item $\ell = 0$のとき，到達不能である．
    \item $\ell = \ell + 1$とする．
    \item $\ell = 1$のとき，到達不能である．
    \item $\ell = \ell + 1$とする．
    \item $\ell = 2$のとき，到達可能である． 
  \end{enumerate}

  \begin{exampleblock}{$k$彩色遷移問題の例}
    \begin{columns}
      \begin{column}{0.3\textwidth}
        \centering
        \input{tikz/graph0.tex}
        $t=0$
      \end{column}
      \begin{column}{0.05\textwidth}
        \textbf{$\longrightarrow$}
      \end{column}
      \begin{column}[]{0.3\textwidth}
        \centering
        \input{tikz/graph1.tex}
        $t=1$
      \end{column}
      \begin{column}{0.05\textwidth}
        \textbf{$\longrightarrow$}
      \end{column}
      \begin{column}{0.3\textwidth}
        \centering
        \input{tikz/graph2.tex}
        $t=2$
      \end{column}
    \end{columns}
  \end{exampleblock}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 有界組合せ遷移
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{有界組合せ遷移を表す命題論理式}

  \begin{itemize}
    \item 基の組合せ問題の変数集合
          $\bm{x} = \{x_1,x_2,\ldots,x_n\}$とする．
    \item 各遷移ステップ$t\geq 0$に対して，
          ステップ$t$での各変数の値を表す変数集合
          $\bm{x}^{t} = \{x_1^t,x_2^t,\ldots,x_n^t\}$
          を導入する．
  \end{itemize}

  ステップ長$\ell$を与えたときに構成される論理式を
  $\varphi_{\ell}$とすると，
  \begin{block}{}
    \centering
    $
      \varphi_{\ell} = S(\bm{x}^0)
      \land \bigwedge_{t=0}^{\ell} C(\bm{x}^t) 
      \land \bigwedge_{t=1}^{\ell} T(\bm{x}^{t-1},\bm{x}^{t})
      \land G(\bm{x}^\ell)
    $
  \end{block}

  \begin{itemize}
    \item $S(\bm{x}^0)$はスタート状態の制約を表す論理式である．
    \item $C(\bm{x}^t)$はステップ数$t$における，
          基の組合せ問題の制約を表す論理式である．
    \item $T(\bm{x}^{t-1},\bm{x}^{t})$はステップ数$t-1$と$t$間の，
          遷移制約を表す論理式である．
    \item $G(\bm{x}^\ell)$はゴール状態の制約を表す論理式である．
  \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 基本ソルバー
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{提案する基本ソルバー}

  \begin{block}{基本ソルバーの手続き}
    \centering
    \begin{enumerate}
      \item ステップ長$\ell=0$とする．
      \item ASP システムを起動する．
      \item $\varphi_{\ell}$を論理プログラムとして記述する． \label{based_solver:loop}
      \item 論理プログラムとファクト形式の問題インスタンスを
            ASP システムに与える．
      \item ASP システムの出力が充足可能であれば終了する．
            充足不能であれば$\ell$を1増加させ，
            ASP システムを終了し，
            \ref{based_solver:loop}に戻り繰り返す．
            \begin{itemize}
              \item $\ell$が基の問題の実行可能解の総数以上になったところで
                    繰り返しを停止できる．
            \end{itemize}
    \end{enumerate}
  \end{block}

  \begin{itemize}
    \item 基本ソルバーは手続きを単純に実装したものである．
  \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 基本ソルバー
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{基本ソルバーにおける$k$彩色遷移問題の ASP 符号化}

  $k$彩色遷移問題を解く2つの ASP 符号化，
  \code{changed}と\code{unchanged}を考案した．

  \begin{exampleblock}{}\centering
    \lstinputlisting{code/gcrp_cc_changed.lp}
  \end{exampleblock}

  %\begin{block}{}\centering
  %  $k$彩色遷移問題を解く3種類のASP符号化，vrc1, vrc2, vrc3 を考案．
  %\end{block}
  %
  %\begin{itemize}
  %\item 各符号化は，
  %  \structure{「各遷移で色が変化する頂点はただ一つのみ」}という遷
  %  移制約の表現方法が異なる．
  %\item 表中の$|V|$は，グラフの頂点数を表す．
  %\end{itemize}
  %
  %\begin{exampleblock}{}\centering
  %  \input{table/encoding.tex}
  %\end{exampleblock}
  %
  %\begin{itemize}
  %\item 特に，vrc3符号化は基礎化後の ASP のルール数を抑えるように工夫
  %  されており，大規模な問題に対する有効性が期待できる．
  %\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 基本ソルバー
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{ファクトと$S(\bm{x}^0)$}
  
  \begin{exampleblock}{}
    \begin{lstlisting}[]
      col(1..c).    t(0..length).
    \end{lstlisting}
  \end{exampleblock}
  \begin{itemize}
    \item 色数とステップ数をファクトで表している．
    \item \code{c}と\code{length}は定数であり，
          実行時にオプションから与えられる．
    \item \code{length}はステップ長$\ell$に対応している．
  \end{itemize}

  \begin{exampleblock}{}
    \centering
    \begin{lstlisting}
      :- not color(X,C,0), start(X,C).
    \end{lstlisting}
  \end{exampleblock}
  \begin{itemize}
    \item $S(\bm{x}^0)$に対応するルールを，
          一貫性制約を用いて表している．
  \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 基本ソルバー
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{$C(\bm{x}^t)$}

  $C(\bm{x}^t)$は2つのルールにより表される．
  
  \begin{exampleblock}{}
    \begin{lstlisting}
      1 { color(X,C,T): col(C) } 1 :- node(X), t(T).
    \end{lstlisting}
  \end{exampleblock}
  \begin{itemize}
    \item \code{color(X,C,T)}はステップ数\code{T}において，
          頂点\code{X}が色\code{C}で塗られることを意味する．
    \item 個数制約を用いて，1つの色で塗られることを表している．
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
      :- not { color(X,C,T); color(Y,C,T) } 1, 
         edge(X,Y), col(C), t(T).
    \end{lstlisting}
  \end{exampleblock}
  \begin{itemize}
    \item 個数制約を用いて，辺で結ばれた2つの頂点のうち，
          色\code{C}で塗られるのは1つ以下であることを表している．
          \begin{itemize}
            \item 辺で結ばれた頂点は同じ色で塗られないという制約に対応している．
          \end{itemize}
  \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 基本ソルバー
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{$T(\bm{x}^{t-1},\bm{x}^{t})$}

  \begin{exampleblock}{}
    \begin{lstlisting}
      changed(X,T) :- color(X,C1,T), color(X,C2,T-1),
                      C1 != C2, T >= 1.
    \end{lstlisting}
  \end{exampleblock}
  \begin{itemize}
    \item ステップ数$T-1$とステップ数$T$で頂点$X$の色が変化したことを意味する
          アトム\code{changed(X,T)}を導入している．
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
      :- not 1  { changed(X,T) } 1, t(T), T >= 1.
    \end{lstlisting}
  \end{exampleblock}
  \begin{itemize}
    \item 色が変わる頂点は各遷移において1つであることを表している．
  \end{itemize}
  \bigskip
  \begin{itemize}
    \item \code{unchanged}符号化は，$T(\bm{x}^{t-1},\bm{x}^{t})$
          の表し方が異なる．
  \end{itemize}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 基本ソルバー
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{$G(\bm{x}^\ell)$}

  \begin{exampleblock}{}
    \begin{lstlisting}
      :- not color(X,C,length), goal(X,C).
    \end{lstlisting}
  \end{exampleblock}
  \begin{itemize}
    \item 一貫性制約を用いて表している．
  \end{itemize}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 基本ソルバー
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{基本ソルバーの問題点}

  \begin{block}{}
    \centering
    $
      \varphi_{\ell} = S(\bm{x}^0)
      \land \bigwedge_{t=0}^{\ell} C(\bm{x}^t) 
      \land \bigwedge_{t=1}^{\ell} T(\bm{x}^{t-1},\bm{x}^{t})
      \land G(\bm{x}^\ell)
    $
  \end{block}
  
  \begin{itemize}
    \item $\varphi_{\ell}$と$\varphi_{\ell-1}$に含まれる制約のほとんどは同じである．
  \end{itemize}

  \begin{block}{節集合として見たときの共通要素と非共通要素}
    \centering
    $
      \varphi_{\ell -1} \oplus \varphi_{\ell} = 
      \{C(\bm{x}^{\ell}), T(\bm{x}^{\ell -1}, 
      \bm{x}^{\ell}), G(\bm{x}^{\ell -1}), G(\bm{x}^{\ell})\}
    $ \\
    $
      \varphi_{\ell -1} \land \varphi_{\ell} =
      \{S(\bm{x}^0) \land \bigwedge_{t=0}^{\ell-1} C(\bm{x}^t)
      \land \bigwedge_{t=1}^{\ell-1} T(\bm{x}^{t-1},\bm{x}^{t})\}
    $
  \end{block}
  \bigskip

  基本ソルバーでは各$\varphi_{\ell}$に対して毎回 ASP システムを実行するため，
  \begin{itemize}
    \item 学習節が引き継がれず同一の探索空間を繰り返し調べる必要がある
    \item 同一のルールを繰り返し基礎化する必要がある
  \end{itemize}
  といった問題点が存在する．

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 改良ソルバー
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{提案する改良ソルバー}

  \begin{block}{改良ソルバーの手続き}
    \begin{enumerate}
      \item ASP システムを起動する．
      \item ファクト形式の問題インスタンスと，
            各制約に対応したルールを表す複数のサブプログラムから構成された
            論理プログラムを与える．
      \item ステップ長$\ell=0$とする．
      \item $\ell>0$であれば，$G(\bm{x}^{\ell -1})$を
            表すルールを削除する． \label{improved_solver:loop}
      \item $\ell=0$であれば，$S(\bm{x}^0)$を
            表すルールを追加する．
      \item $C(\bm{x}^{\ell})$と$T(\bm{x}^{\ell-1},\bm{x}^{\ell})$
            を表すルールを追加する．
      \item $\varphi_{\ell}$の到達可能性を検査する．
      \item ASP システムの出力が充足可能であれば終了する．
            充足不能であれば$\ell$を1増加させ，
            ASP システムを終了し，
            \ref{improved_solver:loop}に戻り繰り返す．
            \begin{itemize}
              \item $\ell$が基の問題の実行可能解の総数以上になったところで
                    繰り返しを停止し，ASP システムを終了できる．
            \end{itemize} \label{improved_solver:end}
    \end{enumerate}
  \end{block}

  \begin{itemize}
    \item 改良ソルバーは，{\clingo}の PythonAPI を用いて実装した．
  \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 改良ソルバー
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{改良ソルバーの実装}

  続き\ref{improved_solver:loop}--\ref{improved_solver:end}
  を実装したものを以下に示す．
  \begin{exampleblock}{}
    \lstinputlisting{code/core.lp}
  \end{exampleblock}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 改良ソルバー
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{PythonAPI (1/2)}

  \begin{itemize}
    \item 変数\code{step}はステップ長$\ell$を意味する．
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
      parts = []
    \end{lstlisting}
  \end{exampleblock}
  \begin{itemize}
    \item ステップ長$\ell$のときに追加するルールを記憶するリストである．
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
      parts.append(("check", [step]))
    \end{lstlisting}
  \end{exampleblock}
  \begin{itemize}
    \item 与えられる論理プログラムはいくつかのブロックに分かれている．
          ブロックはサブプログラムに相当する．
    \item \code{check}ブロックに含まれるルールに，ステップ長として$\ell=$\code{step}
          を与えたもの追加している．
  \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 改良ソルバー
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{PythonAPI (2/2)}

  \begin{exampleblock}{}
    \begin{lstlisting}
      prg.release_external(clingo.Function
          ("query", [step-1]))
    \end{lstlisting}
  \end{exampleblock}
  \begin{itemize}
    \item $G(\bm{x}^{\ell -1})$を
          表すルールを削除している．
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
      prg.ground(parts)
    \end{lstlisting}
  \end{exampleblock}
  \begin{itemize}
    \item 記憶したルールの基礎化を行っている．
  \end{itemize}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 改良ソルバー
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{改良ソルバーにおける ASP 符号化}

  \code{changed}符号化を改良ソルバーに対応させたものを示す．
  \begin{exampleblock}{}
    \lstinputlisting{code/gcrp_cc_changed_inc.lp}
  \end{exampleblock}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 改良ソルバー
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{ASP 符号化の変更点 (1/2)}

  %\begin{itemize}
  %  \item ステップ数を表すファクトを削除した．
  %\end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
      #program base.
      #program step(t).
      #program check(t).
    \end{lstlisting}
  \end{exampleblock}
  \begin{itemize}
    \item \code{base}ブロックには，
          ファクトと制約$S$に対応するルールが含まれる．
    \item \code{step(t)}ブロックには，
          制約$C$と制約$T$に対応するルールが含まれる．
    \item \code{check(t)}ブロックには，
          制約$G$に対応するルールが含まれる．
  \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 改良ソルバー
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{ASP 符号化の変更点 (2/2)}

  \begin{exampleblock}{}
    \begin{lstlisting}
      :- not color(X,C,t), goal(X,C), query(t).
    \end{lstlisting}
  \end{exampleblock}
  \begin{itemize}
    \item \code{query(t)}に偽を割当てることで，必ず一貫性制約を
          満たさなくなる．
    \item 一貫性制約を満たさなくすることは，
          $G(\bm{x}^{\ell -1})$を
          表すルールの削除に対応している．
  \end{itemize}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ベンチマーク
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{ベンチマークの作成}

  \begin{itemize}
    \item 組合せ遷移問題の実践的な研究は始まったばかりであり，
          ベンチマーク問題の整備も重要な課題の一つである．
    \item 本研究では$k$彩色遷移問題をベンチマーク問題として用いる．
    \item ステップ長の上限値として与える実行可能界の総数を求められる，
          グラフ点彩色問題が必要となる．
          \begin{enumerate}
            \item \textit{COLOR04}で公開されているグラフ点彩色問題のグラフ127個のうち，
                  彩色数が判明している44個~[Tamura+ '09] をベンチマーク問題の候補とした．
            \item 44個のグラフに対して，彩色数での実行可能解を全列挙することが可能
                  かを調査した．
          \end{enumerate}
    \item 総数を求められた9個のグラフから各10問ずつ，計90問のベンチマーク問題を作成した．
          \begin{itemize}
            \item スタート状態とゴール状態はランダムに選んだ．
          \end{itemize}
    \item 実行可能解の総数は，最少で120個，最大で約28億個である．
  \end{itemize}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 実験環境
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}\frametitle{実験概要}
  提案した2つのソルバーの評価にあたり，以下の実験を行った．
  \bigskip
  \begin{itemize}
    \item \structure{比較対象}: 
          \begin{itemize}
            \item 基本ソルバー: \code{changed}符号化と\code{unchanged}符号化
            \item 改良ソルバー: \code{changed_inc}符号化と\code{unchanged_inc}符号化
          \end{itemize}
    \item \structure{ベンチマーク問題}: 作成した$k$彩色遷移問題(90問)
    \item \structure{ステップ長の上限値}: 基となるグラフ点彩色問題の実行可能解の総数
          \begin{itemize}
            \item グラフmyciel4から作成した問題については，{\clingo}が対応している数
                  よりも解の総数が大きかったため，
                  上限値を$2^{31}-1$とした．
          \end{itemize}
    \item \structure{ASPシステム}: \textit{clingo-5.4.0} \textit{jumpy}
    \item \structure{制限時間}: 3600秒/問
    \item \structure{環境}: Mac mini，3.2GHz 6コア Intel Core i7，64GB メモリ
  \end{itemize}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 実験結果
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}\frametitle{実験結果: 解けた問題数}

実験結果は以下の通りである．
\bigskip

\begin{exampleblock}{}
  \centering
  \scalebox{0.8}{\input{table/result.tex}}
\end{exampleblock}
  
  \begin{itemize}
    \item 90問中71問について，到達可能性を確認できた．
    \item \code{unchanged_inc}符号化は他が解いた問題をすべて解いていた．
    \item 改良ソルバーの有効性が確認できた．
  \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 実験結果
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}\frametitle{実験結果: カクタスプロット}

  \begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{fig/cactus.eps}
  \end{figure}

  \begin{itemize}
    \item 改良ソルバーは基本ソルバーより多くの問題を高速に解いている．
    \item \code{unchanged}符号化は\code{changed}符号化より多くの問題を高速に解いている．
  \end{itemize}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 今後の課題
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}\frametitle{まとめと今後の課題}

  \begin{block}{まとめ}
    \begin{itemize}
      \item 有界組合せ遷移を提案した．
      \item 有界組合せ遷移を解く2つのソルバーを提案した．
      \begin{itemize}
        \item 特に改良ソルバーは{\clingo}の PythonAPI を用いて高速化を図っている．
      \end{itemize}
      \item $k$彩色遷移問題を解く二つの符号化を提案した．
      \item 独自に作成したベンチマーク問題を用い，2つのソルバー及び2つの符号化の評価
            実験を行った．
      \begin{itemize}
        \item 実験の結果，改良ソルバーの優位性が確かめられた．
      \end{itemize}
    \end{itemize}
  \end{block}
  
  \begin{alertblock}{今後の課題}
    \begin{itemize}
      \item 改良ソルバーの高速化．
      \item 組合せ遷移問題の記述例の蓄積．
      \item $k$彩色遷移問題の ASP 符号化の高速化．
    \end{itemize}
  \end{alertblock}

\end{frame}

%###########################################################
%##### 補助スライド ########################################
%###########################################################

\input{subslide.tex}

\end{document}