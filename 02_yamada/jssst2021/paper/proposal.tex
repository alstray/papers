%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{ASPに基づく組合せ遷移ソルバーの解法}\label{chap:proposal}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
ASP 技術を用いた組合せ遷移問題の解法として，
\textbf{有界組合せ遷移}(Bounded Combinatorial Reconfiguration)
を提案し，そのソルバーの実装方法について述べる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{有界組合せ遷移}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

有界組合せ遷移では，組合せ遷移問題に対して，制限された長さの(すなわち
有界の)遷移系列を論理プログラムとして記号的に表現し，その論理プログラ
ムを ASP システムで実行することにより，到達可能性の検査を行う．
与えられた組合せ問題とその2つの実行可能解について，
ASP システムが充足可能と判定した場合，
制限された長さの到達可能な遷移系列が存在することを意味する．
逆に充足不能と判定した場合，制限された長さでは到達不能である
ことを意味する．この場合，遷移系列の長さを増加させた論理プログラム
を構成し，再び ASP システムによる実行を繰り返す．
有界組合せ遷移は，到達可能な遷移系列を探すだけで，
到達不能の証明は行わない不完全な手続きであるが，検査すべき遷移系列の長
さに上限を設定できる場合には，完全な手続きとなる．
例えば，基の組合せ問題の直径 (任意の2つの実行可能解の最短経路のうちの
最大長)を上限とすればよい~\footnote{%
理論的には，問題の直径を越えるまで手続きを繰り返せばよいが，
実用的な問題ではしばしば直径が大きすぎ，現実的には適用できない}．


\vskip 10em


本研究では，解集合プログラミングに基づく組合せ遷移ソルバーを2種類提案する．
提案するソルバーの構成図を図\ref{fig:arch}に示す．
提案する2種のソルバーは組合せ遷移ソルバー内の仕組みが異なる．
ASP システムには{\clingo}を利用する．
提案手法では，組合せ遷移問題の基本的な入力である
基となる組合せ問題と二つの実行可能解に加え，ステップ長$l$も与える．
本来の問題では
「ある組合せ問題における，
与えられた二つの実行可能解の到達可能性」
を解くのに対し，ステップ長を加えた場合は
「ある組合せ問題における，
ステップ長$l$での与えられた二つの実行可能解の到達可能性」
を解くことになる．
基となる組合せ問題の実行可能解の総数を$M$とすると，
$0 \le l \le M-1$として問題を解くことで
元の組合せ遷移問題の到達可能性が求まる．
一つでも到達可能である$l$が存在すれば元の問題でも到達可能となる．
また，すべての$l$で到達不能であれば元の問題でも到達不能となる．

組合せ遷移問題のインスタンスは ASP ファクト形式で与えられる．
コード\ref{code:gcrp_example.lp}は，
$k$彩色遷移問題のファクト表現である．
1～7行目はグラフのファクト表現である．
\code{n(4).}は頂点数が4個であることを，
\code{e(4).}は辺が4本であることを意味する．
%4～7行目は\ref{code:color.lp}内のグラフのファクト表現と同じである．
4～7行目は頂点と辺の存在をファクトとして表している．
9～10行目では初期状態をファクトとして表している．
\code{start(X, C)}は初期状態において頂点\code{X}が
色\code{C}で塗られることを意味する．
12～13行目では目標状態をファクトとして表している．
\code{goal(X, C)}は目標状態において頂点\code{X}が
色\code{C}で塗られることを意味する．

\lstinputlisting[float=tb,caption={%
$k$彩色遷移問題のファクト表現 (\code{gcrp_example.lp})},%
captionpos=b,frame=single,label=code:gcrp_example.lp,%
xrightmargin=1zw,% 
xleftmargin=1zw,% 
numbersep=5pt,%
numbers=left,%
breaklines=true,%
columns=fullflexible,keepspaces=true,%
basicstyle=\ttfamily\scriptsize]{code/gcrp_example.lp}

\subsection{基本ソルバー} \label{sec:based_solver}

提案する基本ソルバーは，組合せ遷移問題をASPファクト形式で表したファイルと
問題を解くための ASP 符号化，及び$M$が与えられたとき，
ステップ長$l$の値を変化させならがASPシステムを繰り返し起動し
問題を解き到達可能性を出力する．
組合せ遷移問題を解く符号化の例として，
$k$彩色遷移問題を解く2種類の符号化
\code{changed}と\code{unchanged}をそれぞれ
コード\ref{code:gcrp_cc_changed.lp}と
コード\ref{code:gcrp_cc_unchanged.lp}に示す．

%コード名にccを入れる？入れない？
\lstinputlisting[float=t,caption={%
基本ソルバーにおいて$k$彩色遷移問題を解く\code{changed}符号化 (\code{gcrp_cc_changed.lp})},%
captionpos=b,frame=single,label=code:gcrp_cc_changed.lp,%
xrightmargin=1zw,% 
xleftmargin=1zw,% 
numbersep=5pt,%
numbers=left,%
breaklines=true,%
columns=fullflexible,keepspaces=true,%
basicstyle=\ttfamily\scriptsize]{code/gcrp_cc_changed.lp}

\lstinputlisting[float=t,caption={%
基本ソルバーにおいて$k$彩色遷移問題を解く\code{unchanged}符号化 (\code{gcrp_cc_unchanged.lp})},%
captionpos=b,frame=single,label=code:gcrp_cc_unchanged.lp,%
xrightmargin=1zw,% 
xleftmargin=1zw,% 
numbersep=5pt,%
numbers=left,%
breaklines=true,%
columns=fullflexible,keepspaces=true,%
basicstyle=\ttfamily\scriptsize]{code/gcrp_cc_unchanged.lp}

コード\ref{code:gcrp_cc_changed.lp}において，
1行目では定数を用いて色\code{1}から色\code{c}までを定義している．
2行目では定数を用いてステップ\code{0}からステップ\code{l}までを定義している．
5行目では一貫性制約を用いて初期状態を定義しており，
「\code{start(X,C)}ならば\code{color(X,C,0)}である」を意味する．
8～9行目では，各ステップにおいてグラフ点彩色問題の制約を満たすことを，
基数制約を用いて定義している．
8行目は「各ステップにおいて，各頂点は一つの色で塗られる」
を意味する．
9行目は「各ステップにおいて，
辺で結ばれた二つの頂点で色\code{C}で塗られる頂点は一つ以下」
を意味する．
12～13行目では遷移制約を定義している．
12行目で定義している\code{changed(X, T)}は，
「ステップ\code{T-1}とステップ\code{T}で頂点\code{X}の色が
変化した」を意味する．
13行目では一貫性制約と個数制約を用いて
「各ステップで色が変化する頂点は一つ」という制約を表している．
16行目では一貫性制約を用いて目標状態を定義しており，
「\code{goal(X,C)}ならば\code{color(X,C,l)}である」を意味する．

コード\ref{code:gcrp_cc_unchanged.lp}は，
遷移制約の表し方がコード\ref{code:gcrp_cc_changed.lp}
と異なる．
12行目で定義している\code{unchanged(X, T)}は，
「ステップ\code{T-1}とステップ\code{T}で頂点\code{X}の色が
変化しなかった」を意味する．
13行目では一貫性制約と個数制約を用いて
「各ステップで色が変化しない頂点は\code{N-1}個」という制約を表している．
ここで\code{N}はグラフの頂点数である．

基本ソルバーでは，ASP システムの起動や
ルールの\textbf{基礎化}による
オーバーヘッドが大きいという問題がある．
基礎化とは，一階述語論理に代入を行い
命題論理へと変換することをいう．
コード\ref{code:gcrp_cc_changed.lp}と
コード\ref{code:gcrp_cc_unchanged.lp}において，
ある$l$で生成される節集合から
目標状態を定義する制約を除いたものを
$C(l)$とすると，
\begin{align}
  C(l) \: \subseteq \: C(l') \: (l \: < \: l')
\end{align}
となるため，同じ節を何度も生成することになる．

\subsection{改良ソルバー}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{arch.tex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\lstinputlisting[float=tb,caption={%
\clingo のPythonAPIを用いた改良ソルバー (\code{core.lp})},%
captionpos=b,frame=single,label=code:core.lp,%
xrightmargin=1zw,% 
xleftmargin=1zw,% 
numbersep=5pt,%
numbers=left,%
breaklines=true,%
columns=fullflexible,keepspaces=true,%
basicstyle=\ttfamily\scriptsize]{code/core.lp}

\ref{sec:based_solver}節で述べた問題点を改善するために
改良ソルバーを提案した．
改良ソルバーでは{\clingo}のインクリメンタルサーチモードを用いる．
コード\ref{code:core.lp}は，{\clingo}の 
PythonAPI\footnote{https://potassco.org/clingo/python-api/5.4/} 
を用いて実装したものである．
4～5行目で定義されている関数\code{get}は，
入力があった場合は入力を取得し，そうでない場合は
デフォルトで設定されている値を取得する．
8～9行目ではソルバーの停止条件となる2個の変数を定義している．
8行目では\code{core_stop}を定義している．
\code{core_stop}は\code{SAT}, \code{UNSAT}, \code{UNKNOWN}
のいずれかを取る．
\code{core_stop}は別の論理プログラム内で定義されている場合は
\code{core_stop}から値を取得し，
定義されていない場合は\code{SAT}となる．
ソルバーは，{\clingo}が
\code{core_stop}と同じ結果を出力するまで
インクリメンタルに問題を解き続ける．
9行目ではステップ長の上限値となる値\code{core_max}を定義している．
\code{core_max}は論理プログラムで定義される\code{core_max}
から値を取得する．
値が与えられなかった場合は\code{Null}となり，
ステップ長の上限値は指定されない．
このとき，停止条件は\code{core_stop}のみに依存する．
\code{core_max}を$M-1$とすることで，
基本ソルバーと同様に到達可能性を判定できる．

11～25行目では，ステップ長を1ずつ増加させながら繰り返し問題を解いている．
11行目で定義されている\code{step}はステップ長のカウンタである．
\code{ret}は{\clingo}の実行結果を受け取る変数である．
12～14行目のループの条件は，
2個の条件が同時に成り立つことを求めている．
一つ目の条件は「ステップ長が定義されているならば上限値を超えていない」
を意味する．
二つ目の条件は「前回の結果が停止条件と同じではない」
を意味する．
15行目で定義している\code{parts}は，
基礎化するルールを記憶するためのものである．
16～17行目では，\code{parts}にルールを追加している．
16行目では，\code{check}ブロックに書かれているルールについて，
ステップ長を表す変数に\code{step}の数値を代入する，ということを
追加している．
17行目では，\code{step}ブロックに書かれているルールについて，
16行目と同様のことを行っている．
18行目～22行目は\code{step}の値によって挙動が変わる．
\code{step}$ > 0$のときは，前の段階で割当てられた
\code{query(step-1)}の割当てを偽に変更する．
% cleanupの説明ができていない可能性あり．
そうでないときは，\code{base}に書かれているルールを\code{parts}に
加える．
23行目では\code{parts}に記憶されているものを基礎化し命題論理における
節として生成する．
24行目では\code{query(step)}に真を割当て，{\clingo}が問題を解く時に
割当てが変更されないようにしている．
25行目では問題を解き\code{ret}に結果を代入し，
その後\code{step}を増加させる．

27～33行目では出力を行う．
27行目ではステップ長を出力する．
到達可能のときは得られた解のステップ長が出力される．
これは最短のステップ長でもある．
到達不能のときは$M-1$が出力される．
28行目以降は到達可能性の結果の出力である．
\code{step}が$0$ではなく，
かつ\code{ret}の中身が\code{core_stop}と等しい時には
到達可能であることを意味する\code{REACHABLE}を出力する．
そうでないときには，到達不能を意味する\code{UNREACHABLE}
を出力する．

36～37行目では，\code{check}ブロック内にある\code{qurey(t)}を
\code{external}変数として定義している．
これは19行目や24行目の操作を行うのに必要となる．

\lstinputlisting[float=tb,caption={%
基本ソルバーにおいて$k$彩色遷移問題を解く\code{unchanged}符号化 (\code{gcrp_cc_unchanged_inc.lp})},%
captionpos=b,frame=single,label=code:gcrp_cc_unchanged_inc.lp,%
xrightmargin=1zw,% 
xleftmargin=1zw,% 
numbersep=5pt,%
numbers=left,%
breaklines=true,%
columns=fullflexible,keepspaces=true,%
basicstyle=\ttfamily\scriptsize]{code/gcrp_cc_unchanged_inc.lp}

組合せ遷移問題を解く ASP 符号化も，
改良ソルバーに対応させる必要がある．
コード\ref{code:gcrp_cc_unchanged.lp}の\code{unchanged}符号化
を対応させた\code{unchanged_inc}符号化をコード\ref{code:gcrp_cc_unchanged_inc.lp}
に示す．
変更点は以下の通りである．
\begin{itemize}
  \item 1行目の\code{#const}では，\code{core_max}の値を\code{l}として宣言している．
  \begin{itemize}
    \item \code{core_stop}については宣言していないため\code{SAT}となる．
  \end{itemize}

  \item ルールを\code{base}などのブロックに割当てるための記述を追加している．
  5～6行目が\code{base}に，10～14目が\code{step}に，17行目が\code{check}に
  割当てられている．

  \item ステップを表すファクト\code{t(0..l)}を削除した．
  \item 目標状態を表すルールに\code{query(t)}を追加した．
  \begin{itemize}
    \item \code{query(t)}に偽を割当てることで，前の段階で生成された
    一貫性制約が成り立たないようにしている．
  \end{itemize}
\end{itemize}

% \begin{comment}
% \begin{figure}[tb]
%   \centering
%   \begin{tabular}{l}\hline
%     \textbf{Algorythm} improved solver\\\hline
%     %~1: input: a problem $P$ \\
%     ~2: input: $stop$, $min$, $max$ \\
%     ~3: launch ASP system $S$; \\
%     ~4: $step := 0$; \\
%     ~5: $ret := None$; \\
%     ~6: \bf{repeat} \\
%     ~7: \quad \quad generate a empty list $parts$; \\
%     ~8: \quad \quad $append\_list(parts, "check", step)$; \\
%     ~9: \quad \quad $append\_list(parts, "step", step)$; \\
%     10: \quad \quad \textbf{if} $step > 0$ \textbf{then} \\
%     11: \quad \quad \quad \quad $assign\_false(S, "query", step-1)$; \\
%     12: \quad \quad \textbf{else} \\
%     13: \quad \quad \quad \quad $append\_list(parts, "base", step)$; \\
%     14: \quad \quad \textbf{end if} \\
%     15: \quad \quad $ground(S, parts)$; \\
%     16: \quad \quad $assign\_true(S, "query", step)$; \\
%     17: \quad \quad $ret := solve(S)$; \\
%     18: \quad \quad $step := step+1$; \\
%     19: \textbf{until} $step > max$ or $ret == stop$ and $step \ge min$\\
%     20: close $S$; \\
%     21: \textbf{if} $ret == stop$ and $step \ge min$ \textbf{then} \\
%     22: \quad \quad \textbf{return} REACHABLE \\
%     23: \textbf{else} \\
%     24: \quad \quad \textbf{return} UNREACHABLE \\
%     25: \textbf{end if} \\ \hline
%   \end{tabular}
%   \caption{改良ソルバーのアルゴリズム}
%   \label{algo:inc_solver}
% \end{figure}
% 改良ソルバーのアルゴリズムを図\ref{algo:inc_solver}に示す．

% \begin{enumerate}
%   \item 終了条件と，ステップ数の下限と上限を与える．
%   \item ASPシステムを起動する．
%   \item $step$と$ret$の値を初期化する．
%   \item 空のリスト$parts$を生成する．
%   $parts$は基礎化するものを記憶するためのものである．
%   \item 論理プログラム内において，
%   \code{check}ブロックと\code{step}ブロックに
%   割り振られたステップ数$step$のルールを$parts$に加える．

%   \begin{itemize}
%     \item \code{check}ブロックには，主に目標状態に関するルールが記述される．
%     \item \code{step}ブロックには，主に各ステップで満たされるべきルールが記述される．
%   \end{itemize}

%   \item $step \ge 0$のとき，ステップ数$step-1$で基礎化された
%   命題変数\code{query(step-1)}を偽とする．そうでないとき，
%   \code{base}ブロックに割り振られたルールを$parts$に加える．
%   \begin{itemize}
%     \item \code{query}は，すでに生成されている前の段階時点における目標状態
%     に関するルールを無効化するためのものである．
%   \end{itemize}

%   \begin{itemize}
%     \item \code{base}ブロックには，
%     ステップ数に関わらず成り立つルールが記述される．
%     \item ファクト形式のファイルなどの，ブロックが明記されてないルールも
%     \code{base}ブロックとみなされる．
%   \end{itemize}

%   \item $parts$内のルールについて，$step$を代入し基礎化する．
%   \item ステップ数$step$で基礎化された命題変数\code{query(step)}を
%   真とする．
%   \item ASP システムにより問題を解く．
%   \item 終了条件を満たすまで，ステップ4～9を繰り返す．
%   \item 結果を出力する．
%   \item ASPシステムを終了する．
% \end{enumerate}
% \end{comment}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
