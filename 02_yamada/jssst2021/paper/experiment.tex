%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{実行実験} \label{chap:experiment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\ref{chap:proposal}章で提案した2種のソルバーの評価実験を行った．
ベンチマークには$k$彩色遷移問題を用いた．

\subsection{ベンチマークの作成}
\begin{table*}[t]
  \centering
  \caption{彩色数における全解数が判明したグラフ}
  \label{tab:bench_graph}
  \input{table/graph}
\end{table*}

評価には，実行可能解の総数を求めることが可能な
グラフ$G$と色数$k$の組合せが必要である．
したがって，初めにベンチマークに使用可能なグラフと色数について調査を行った．
調査するグラフとして，
Graph Coloring and its Generalization\footnote{https://mat.tepper.cmu.edu/COLOR04/}
で公開されているグラフ彩色問題127問のうち，
\textbf{彩色数}が判明している44問~\cite{DBLP:journals/constraints/TamuraTKB09}を用いた．
彩色数とはグラフを彩色可能な色数の最小値である．

44問のグラフに対して，
色数を彩色数としたときに全解数を求めることが可能か調査を行った．
調査にあたり，各グラフを ASP ファクト形式にしたうえで{\clingo}を使用した．
グラフ点彩色問題を解く論理プログラムとして，
コード~\ref{code:color.lp}からグラフのファクト表現を除いたものを利用とした．
それぞれの制限時間は1時間とした．
{\clingo}のバージョンは5.4.0，オプションは\textsl{tweety}と\textsl{crafty}を用いた．
調査環境はMac Mini，3.2GHz 6コア Intel Core i7，64GBメモリである．

結果，9つのグラフにおいて全解数を求めることができた．
全解数が判明したものについて，表~\ref{tab:bench_graph}に示す．
全解数が100万個未満のグラフについては，全ての解からランダムで2個の解を抽出した．
一方，全解数が100万個以上存在するものについては出力する解の個数を10万個に制限し，
その中からランダムで2個の解を抽出した．
そして各グラフごとに10問ずつ，計90問のベンチマークを作成した．

\subsection{実行実験}
\begin{figure*}[t]
  \centering
  \includegraphics[scale=0.9]{fig/cactus.eps}
  \caption{評価実験の結果のカクタスプロット}
  \label{fig:cactus}
\end{figure*}

% 案: 平均時間と合計数だけ本文中にのせ，詳細は付録とする
\begin{table*}[t]
  \centering
  %\scriptsize
  \tiny
  \caption{CPUTimeに基づく比較}
  \label{tab:result_time}
  \input{table/time.tex}
\end{table*}

90問のベンチマークを利用して2種のソルバーとそれぞれ2種の符号化，
計4通りに対して評価実験を行った．
今回の実験で用いる{\clingo}の仕様上，
定数として与えられる最大値は$2^31$となる．
これはグラフmyciel4の彩色数における実行可能解の総数より小さい．
そのため，改良ソルバーでmyciel4に関する問題を解く場合は
ステップ長の上限値として$2^31$を与えた．
このとき，より短いステップにおいて到達可能である場合は
判定可能である．
1問あたりの制限時間は1時間とした．
{\clingo}のバージョンは5.4.0，オプションは\textsl{jumpy}を用いた．
調査環境はMac Mini，3.2GHz 6コア Intel Core i7，64GBメモリである．

実験の結果，到達可能であると判定できたものが11問，
到達不可能であると判定できたものが60問存在した．
図\ref{fig:cactus}は実験結果をカクタスプロットとして表したものである．
図\ref{fig:cactus}は縦軸がCPU時間，横軸が解けた問題数を表し，
右下にあるグラフほどより速く，より多くの問題が解けたことを意味する．
左側に寄っている二つが基本ソルバーの結果であり，
右側に寄っている二つが改良ソルバーの結果である．
改良ソルバーがより速く，多くの問題を解いてることがわかる．
また，それぞれのソルバーで\code{changed}符号化と\code{unchanged}
を比較すると，\code{unchanged}符号化がより良い性能を
示している．

表\ref{tab:result_time}は，4種の実験における CPU 時間
を表にしたものである．
左から順にインスタンス名，到達可能性，4種のCPU 時間となっている．
インスタンス名はグラフ名，色数，識別番号を\_で連結している．
たとえば col4 であれば色数4を意味する．
到達可能であるものはREACHABLE，到達不能であるものはUNREACHABLEとしている．
CPU 時間は左から順に基本ソルバーにおける\code{changed}符号化，
\code{unchanged}符号化，改良ソルバーにおける\code{changed}符号化，
\code{unchanged}符号化となっている．
また下2行は解けた問題におけるCPU時間の平均と解けた問題数である．
特に改良ソルバーにおける\code{unchanged_inc}が最も多くの問題を解いていた．
これは他のものが解いた問題すべてを含んでいる．
平均時間についても改良ソルバーによるものが基本ソルバーによるものより速く，
\code{changed}符号化と\code{unchanged}符号化では\code{unchanged}符号化のほうが
速かった．

本実験により改良ソルバーの手法の有効性が確認できた．
また，\code{unchanged}符号化の有効性も確認できた．
これは基礎化によって生成される節数の差によるものと考えられる．
基本ソルバーを例とする．
2種の符号化において差は遷移制約のみである．
ステップ長の上限値を$L$，色数を$C$，グラフの頂点数を$V$とすると，
\code{changed}符号化の遷移制約を基礎化したときの節数が
$L(2 {}_{C}C_{2} V + 1)$
であるのに対し，
\code{unchanged}符号化の同条件の節数は
$L(CV + 1)$
である．
生成される節数の数が少ない場合，
基礎化におけるオーバーヘッドや命題論理として
解くときのオーバーヘッドが減少することが考えられる．
結果，\code{unchanged}符号化が良い結果を示したと考えられる．

本実験で求解できなかった問題に着目すると，
1-Fullins\_3, myciel3, myciel4の3個のグラフから生成された
ベンチマークのみであった．
これらのグラフは実行可能解の総数が多いという特徴がある．
これは組合せ遷移問題としての解の探索空間の大きさを意味するため，
特に到達可能ではないときの難しさに影響したと考えられる．

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
