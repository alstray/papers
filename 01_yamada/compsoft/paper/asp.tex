\section{解集合プログラミング}\label{chap:asp}

ASPの言語は，一般拡張選言プログラムをベースとしている~\cite{Inoue08:jssst}．
本稿では，説明の簡略化のため，そのサブクラスである標準論理プログラムに
ついて説明する．以降，標準論理プログラムを単に論理プログラムと呼ぶ．

\textbf{論理プログラム}は，以下の形式の\textbf{ルール}の有限集合である．
\begin{equation}
 \label{eq:rule}\nonumber
  a_0 ~\mcode{:-}~ a_1 \mcode{,} \dots \mcode{,} a_m \mcode{,}~%
  \naf{a_{m+1}} \mcode{,} \dots \mcode{,} \naf{a_n}\mcode{.}
\end{equation}
ここで，
$0\leq m\leq n$ であり，
各$a_i$はアトム，
$\naf{}$は\textbf{デフォルトの否定}
\footnote{\textbf{失敗による否定}とも呼ばれる．述語論理で定義される否定($\neg$)とは意味が異なる．}，
``\mcode{,}''は連言を表す．
``\mcode{:-}''の左側を\textbf{ヘッド}，右側を\textbf{ボディ}と呼ぶ．
``\code{.}''はルールの終わりを表す終端記号である．
ルールの直観的な意味は，
「$a_1,\ldots,a_m$がすべて成り立ち，$a_{m+1},\ldots,a_n$のそれぞれが
成り立たないならば，$a_0$が成り立つ」である．
ボディが空のルール(すなわち\(a_0~\mcode{:-}~.\))を\textbf{ファクト}と呼び，
``\mcode{:-}''を省略することができる．

ヘッドが空のルールを\textbf{一貫性制約}と呼ぶ．
\begin{equation}
  \label{eq:constr}\nonumber
  \mcode{:-}~ a_1 \mcode{,} \dots \mcode{,} a_m \mcode{,}~%
  \naf{a_{m+1}} \mcode{,} \dots \mcode{,} \naf{a_n}\mcode{.}
\end{equation}
例えば，一貫性制約
``\(\mcode{:-}~ a_1 \mcode{,} a_2 \mcode{.}\)''は，
「$a_1$と$a_2$が両方同時に成り立つことはない」を意味し，
``\(\mcode{:-}~ a_1 \mcode{,}~\naf{a_{2}} \mcode{.}\)''は，
「$a_1$が成り立つならば，$a_2$も成り立つ」を意味する．

ASP言語には，組合せ問題を解くために便利な拡張構文が用意されている．
その代表的なものが\textbf{選択子}と\textbf{個数制約}である．
例えば，選択子
``\(\mcode{\{}a_1\mcode{;}\dots\mcode{;}a_n\mcode{\}.}\)''
をファクトとして書くと，
「アトム集合\(\{a_1,\dots,a_n\}\)の任意の部分集合が成り立つ」を意味する．
個数制約は選択子の両端に選択可能な個数の上下限を付けたものである．
例えば，
``\(\mcode{:-}~a_{0}\mcode{,}~\naf{lb\ \mcode{\{}a_1\mcode{;}\dots\mcode{;}a_n\mcode{\}}\ ub\mcode{.}}\)''
と書くと，
「$a_{0}$が成り立つならば，$a_1,\dots,a_n$のうち，$lb$個以上$ub$個以下
が成り立つ」を意味する．
また，\textbf{重み付き個数制約}(\code{#sum})も用意されている．
例えば，
``\(\mcode{:-}~a_{0}\mcode{,}~\naf{lb\ \mcode{\#sum}~%
\mcode{\{}w_{1}\mcode{:}a_{1}\mcode{;} \dots \mcode{;}w_{n}\mcode{:}a_{n}\mcode{\}}\ ub}\mcode{.}\)''と書くと，
「$a_{0}$が成り立つならば，
$a_1,\dots,a_n$のうち真となるアトムの重み和が$lb$以上$ub$以下
である」を意味する．項$w_{i}$は重みを表す．

\textbf{ASPシステム}は，与えられた論理プログラムから，
安定モデル意味論~\cite{Gelfond88:iclp}
に基づく解集合を計算するシステムである．
本稿では，高性能かつ高機能なASPシステムとして世界中で広く使われている
{\clingo}%~\footnote{\url{https://potassco.org/clingo/}}
を使用する．
{\clingo}を含め最新の高速ASPシステムは，グラウンダーを用いて変数を含
む論理プログラムを変数を含まない論理プログラムに変換(\textbf{基礎化})
したのち，ASPソルバーを用いて解集合を計算する方式が主流となっている．

% 解集合プログラミングを用いた問題解法プロセスは，3つのステップからなる．
% まず最初に，与えられた問題インスタンスをASPのファクト形式に変換する．
% 次に，ファクト形式のインスタンスと，解きたい問題の制約を表現したASP符号化を
% 結合し，ASP システムを用いて論理プログラムの解集合を計算する．
% 最後に，解集合を解釈して元の問題の解を得る．
%
% ここでは，グラフ彩色問題を例として，各ステップ毎に解法プロセスを説明する．
% ASP システムとしては{\clingo}を用いる．
% % 以降で示す論理プログラムのソースコードはすべて{\gringo}言語で書かれている
% % おり，表記上の対応については表~\ref{tbl:map}の通りである．

% グラフ彩色問題とは，辺で結ばれたノードが同じ色にならないように，各ノー
% ドを塗り分ける問題である．
% 例として，図~\ref{fig:graph}のグラフを赤(\code{r})，青(\code{b})，緑
% (\code{g})の3色で塗り分ける問題を考える．
% この問題を表す論理プログラムをコード~\ref{code:color.lp}に示す．

% 2〜4行目は，ノード(\code{node})と辺(\code{edge})をファクトとし
% て書くことによって，図~\ref{fig:graph}のグラフを表している．
% 7行目も同じく，色(\code{col})をファクトで表している．
% %
% 10行目のルールは，個数制約を使って
% 各ノードは一つの色で塗られるという制約を表している．
% アトム\code{color(X,C)}は，ノード\code{X}が色\code{C}で
% 塗られることを意味する．``\code{:}''は条件付きリテラルと呼ばれる
% 拡張構文であり，このルールのヘッドは，
% \code{1 \{color(X,r);color(X,b);color(X,g)\} 1}のように展開される．
% 11行目のルールは，一貫性制約を使って
% 辺で結ばれたノード(\code{X}と\code{Y})は，同じ色(\code{C})で塗られない
% という制約を表している．

% ASP システムは解集合を計算して出力する．
% コード~\ref{code:color.log}に{\clingo}の実行例を示す．
% この出力から，ノード1と5は緑，ノード4と6は赤，ノード2と3は青に塗り分け
% られることがわかる．

%%% Local Variables:
%%% mode: japanese-latex
%%% TeX-master: "paper"
%%% End:
