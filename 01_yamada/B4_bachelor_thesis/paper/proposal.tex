%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\chapter{根付き全域森のASP符号化} \label{chap:prop}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
本章では，解集合プログラミングを用いて根付き全域森を
論理プログラムで表現する方法について述べる．

\section{ASPファクト形式}
入力として与えられるグラフはASPのファクトで表される．図\ref{fig:dnetgraph}
をファクト形式で表現したものをコード\ref{code:graph.lp}に示す．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstinputlisting[float=h,caption={%
図\ref{fig:dnetgraph}のファクト形式 (\code{graph.lp})},%
captionpos=b,frame=single,label=code:graph.lp,%
numbers=left,%
breaklines=true,%
columns=fullflexible,keepspaces=true,%
basicstyle=\ttfamily\scriptsize]{code/graph.lp}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\code{node}は各ノードを表しており，2行目で添字が1から6までのノードを定義している．
アトム\code{root(X)}はノード\code{X}が根であることを意味する．
5行目で1と3のノードが根であることを定義している．
アトム\code{edge(X,Y)}はノード\code{X}と\code{Y}が辺で結ばれていることを意味する．
8～9行目で7つの各辺を定義している．
例として，図\ref{fig:dnetgraph}における辺$s_{1}$は，\code{edge(1,2)}のように表される．

\section{ASP符号化}
根付き全域森の各種制約は複数のルールの集合として簡潔に記述できる．
本研究では，与えられたグラフから根付き全域森探索問題を解く2種類の論理プログラムを考案した．
考案した\code{srf1}符号化をコード\ref{code:srf1.lp}に，
\code{srf2}符号化をコード\ref{code:srf2.lp}にそれぞれ示す．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstinputlisting[float=t,caption={%
根付き全域木の論理プログラム (\code{srf1.lp})},%
captionpos=b,frame=single,label=code:srf1.lp,%
numbers=left,%
breaklines=true,%
columns=fullflexible,keepspaces=true,%
basicstyle=\ttfamily\scriptsize]{code/srf1.lp}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstinputlisting[float=t,caption={%
根付き全域木の論理プログラム (\code{srf2.lp})},%
captionpos=b,frame=single,label=code:srf2.lp,%
numbers=left,%
breaklines=true,%
columns=fullflexible,keepspaces=true,%
basicstyle=\ttfamily\scriptsize]{code/srf2.lp}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% srf1符号化
\code{srf1}符号化は，全部で7つのルールで根付き全域森の制約を表している．
それぞれのルールの意味について説明していく．

2行目のルールは，選択子を使って\ 「\!各辺は解となる森に含まれるか含まれないかのどちらかである」
という制約を表している．
アトム\code{inForest(X,Y)}は，辺\code{edge(X,Y)}が解となる森に含まれることを意味する．

5～7行目は，各連結成分のノードの集合を生成するルールである．
アトム\code{reached(X,R)}，はノード\code{X}が根\code{R}から到達可能であることを意味する．
5行目のルールは，\!「\!各根は自分自身から到達可能である」という制約を表している．
6～7行目のルールは，\!「\!すでに到達可能である各ノードについて，
そのノードと辺で結ばれたノードは同じ根から到達可能である」という制約を表している．

10行目は，根付き全域森の非閉路制約を表すルールである．
各連結成分は木であることから，木の辺の数に関する性質\footnote{ノード数nの木について，%
辺の数は$n - 1$となる．}を基にしている．10行目のルールは，重み付き個数制約を使った一貫性制約で
\ 「\!各根について，$\mbox{(到達可能なノードの数)}-\mbox{(そのノード間で結ばれる辺の数)}=1$である」という制約を表している．

13～14行目は，根付き全域森の根付き連結制約を表すルールである．
13行目のルールは，一貫性制約を使って\ 「\!各ノードは少なくとも1つの根から到達可能である」という
at-least-one制約を表している．
14行目のルールは，一貫性制約を使って\ 「\!各ノードは高々1つの根から到達可能である」という
at-most-one制約を表している．
この2つの制約が各根に対する到達可能な根の数の上下限を表すことで根付き連結制約を表している．

%srf2符号化
\code{srf2}符号化は，全部で6つのルールで根付き全域森の制約を表している．
2～10行目までの各ルールは\code{srf1}符号化と同様にして制約を表している．

13行目は，根付き連結制約を表すルールである．
ASPの拡張構文である個数制約を使った一貫性制約で
\ 「\!各ノードはちょうど1つの根から到達可能である」ことを直接表している．

根付き連結制約の表現による違いについて，
\code{srf2}符号化は\code{srf1}符号化と比べて，問題に符号化を適用した際に生成される制約数
を少なく抑えられることが特長である．
具体的には，ノードの数が$n$個，根の数が$r$個の問題について，
各符号化の根付き連結制約を表すルールが生成する制約数を確認する．
\code{srf1}符号化では，13行目のルールが各ノードに対して符号化した$n$個と，
14行目のルールで，各ノードについて2つの根を選択することにより符号化した$n\times{}_rC_2$個
であり，全部で$n(1+{}_rC_2)$個である．
一方，\code{srf2}符号化は，13行目のルールで各ノードに対して符号化するので，全部で$n$個と少なく
なっていることがわかる．


%%%%%%
% 具体的な制約数を書く
% srf1 V * (1+rC2)
% srf2 V
% これで制約数が少なくなることを説明

%%% Local Variables:
%%% mode: japanese-latex
%%% TeX-master: "paper"
%%% End:
