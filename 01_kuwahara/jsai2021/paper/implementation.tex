\section{ASP ソルバー \textit{clingo} 上での実装}


変数選択ヒューリスティクスの変更には，
論理プログラム上で以下のような表記を用いることで行う. 
\begin{displaymath}
\#heuristic \quad A~ : ~Body. ~~~[w,m]
\end{displaymath}

これは, \textit{Body}が成り立つ時, アトム $A$ の変数ヒューリスティクスを重み
 $w$ と指定子 $m$ に従って変更することを表している. 

変数選択ヒューリスティクスをどのように変更するかは，
指定子によって決定される．
指定子として $true$ と $false$ を例にとり説明をする．
$true$ はアトムに優先的に真を割り当てるようにする指定子で，
$false$ はアトムに優先的に偽を割り当てるようにする指定子である．

コード\ref{code:heu.lp}は, \#\textit{heuristic}ルールを用いた
論理プログラムの例である．
１ 行目には拡張構文である選択子が使用されており，
アトム$a$,$b$は真でも偽でも良いということを表している. 
２ 行目は一貫性制約を用いて，
アトム$a$,$b$が同時に真になることを禁止している．
3,4 行目はそれぞれ$a$,$b$に関する
\#\textit{heuristic}ルールであり，
3 行目は, 優先度１で$a$に真を割り当てることを，
4 行目は, 優先度２で$b$に真を割り当てることを表している．
各アトムのデフォルトのレベルは０であり，
最もレベルの高いアトムから真もしくは偽が割り当てられる．

コード\ref{code:heu.log}に{\clingo}の実行例を示す．
{\clingo}では ``--heu=domain" をオプションとして指定することで，
\#\textit{heuristic}ルールが有効となる．
この実行では，
アトム$b$のみが真となった解が出力されている．
$a$に関しても真を優先的に割り当てるようなルールが記述されているが，
$a$に対するルールが優先度１であるのに対し，
$b$に対するルールは優先度２であるので，
まず$b$に優先して真が割り当てられる．
その後，
一貫性制約によって$a$,$b$が同時に真になることは
禁止されているために
$a$に偽が割り当てられ，
その結果が出力されている．
また，コード\ref{code:heu.lp}で２行目の一貫性制約の記述が無ければ，
$a$,$b$どちらの\#\textit{heuristic}ルールも有効となって，
実行結果は$a$,$b$の両方を含む解が出力されることになる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstinputlisting[float=t,caption={%
変数選択ヒューリスティクスの例 (\code{heu.lp})},%
captionpos=b,frame=single,label=code:heu.lp,%
numbers=left,%
breaklines=true,%
columns=fullflexible,keepspaces=true,%
basicstyle=\ttfamily\scriptsize]{code/heu.lp}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstinputlisting[float=t,caption={%
\code{heu.lp} に対する\textit{clingo}の実行例},%
captionpos=b,frame=single,label=code:heu.log,%
numbers=left,%
breaklines=true,%
columns=fullflexible,keepspaces=true,%
basicstyle=\ttfamily\scriptsize]{code/heu.log}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{LNPS の実装}
LNPS の実装にはプログラミング言語 Python を用い，
実行には {\clingo} の Python インターフェースを利用する．
最適化を行う任意の ASP プログラムに適用して，LNPS による探索を可能にするシステムを実現した．
ASP システムに対し，任意の問題を解く為の ASP プログラムと Python で記述された LNPS プログラムを
与えることで，問題の解を得られるという仕組みになっている．

実際にどのような動作が行われているかを順を追って説明する．
まず既存 ASP 解法によって問題を解き，
ある探索中断基準に基づいて探索を中断し，暫定解を得る．
得た暫定解に対して，destroy 演算によって値割り当ての一部を取り消す．
取り消されなかった値割り当てに対して，
次回探索開始時に優先的に真となるように
\#\textit{heuristic}ルールを生成する．
ルールを有効にした状態で re-search による再探索を行う．
これにより，値割り当てをなるべく維持したままの再探索が実現され，
再度ある基準で再探索を中断，値割り当てを取り消すという動作を繰り返す．

\subsection{destroy 演算の実装}
LNPS では，
暫定解のどの値割り当てを取り消すかに依存しすぎない探索を行うことが可能であると
述べたが，
それでも LNPS の性能には，
適切な destroy 演算を設計する必要がある．
今回実装した複数の destroy 演算の説明をするにあたって，
解く問題の性質を利用したものもあるため，
まず簡単に今回使用した問題である時間割問題について述べる．

本研究で対象とした時間割問題は，
カリキュラムベース・コース時間割問題で，
時間割問題の中でも最も研究が盛んな時間割問題の一つである．
カリキュラムベース・コース時間割は
必ず満たすべきハード制約と，
できるだけ満たしたい重み付きソフト制約から構成され，
違反する制約の重み（ペナルティ）の最小化が目的である．
ハード制約を満たしながら与えられた講義をそれぞれの日時と教室に割り当て，
「受講者数が，教室の収容人数を超えた分だけペナルティが与えられる」などといった
ソフト制約によって目的関数の値が決まる．\\

次に実装した 4 種類の destroy 演算について説明を行う．
    \begin{enumerate}
    \item random $N$\\
       暫定解の値割り当ての中からランダムに$N$\% を選んで取り消す．
       $N$ として０も選択可能であり，その場合，
       解を取り消さずに暫定解の全ての値割り当てに対して優先度を上げる．
       そのため，
       暫定解の値割り当てに近い値割り当ての解への探索を促進させることが狙いとなる．
       値割り当てをある程度の割合で取り消す場合は，
       暫定解の近辺を探索しながら，
       局所的最適解に陥らないようにさせることを狙いとしている．
    \item day-period\\
      ランダムに曜日と時限をそれぞれ一つ選択し，
      選択した曜日の選択した時限に割り当てられている値割り当てを全て取り消す．
      この destroy 演算は，
      割り当てられる教室の変更を促進させ，
      教室に関するソフト制約へのペナルティを改善することを狙いとしている．
  \item day-room\\
   ランダムに曜日と教室をそれぞれ一つ選択し，
   選択した曜日の選択した教室に割り当てられている値割り当てを全て取り消す．
   この destroy 演算は，
   割り当てられる時限の変更を促進させ，
   時限に関する制約へのペナルティを改善することを狙いとしている．
  \item swap-room $N$\\
    暫定解からランダムに$N$\%の値割り当てを選び，
    曜日と時限はそのままで，割り当てられている教室の情報を取り消す．
   この destroy 演算は，
   day-room と比較して割り当てられる教室のみの変更を促進させ，
   より教室に関するソフト制約へのペナルティを改善することを狙いとしている．
    
  \end{enumerate}