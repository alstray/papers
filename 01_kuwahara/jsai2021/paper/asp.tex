\section{ASP ソルバー \textit{clingo} 上での実装}

\subsection{解集合プログラミング (Answer Set Programming; ASP)}
ASP の言語は，
一般拡張選言プログラムをベースとしている．
簡単のため，そのサブクラスである
標準論理プログラムについて説明する． 
以下では，標準論理プログラムを単に論理プログラムと呼ぶ．
論理プログラムは，
以下の形式のルールの有限集合である．
\begin{displaymath}
  \label{eq:rule}
  a_0\leftarrow a_1,\dots,a_m,\naf{a_{m+1}},\dots,\naf{a_n}
\end{displaymath}
ここで，
$0\leq m\leq n$ であり, 
このルールの直観的な意味は，
「$a_1,\ldots,a_m$がすべて成り立ち，
$a_{m+1},\ldots,a_n$のそれぞれが成り立たないならば，
$a_0$が成り立つ」である．
各$a_i$はアトム，
$\naf{}$はデフォルトの否定 (述語論理における否定($\neg$)とは意味が異なる)，
``$,$''は連言($\land$)を表す．
また，$\leftarrow$の左側をヘッド，右側をボディと呼ぶ． 
ボディが空のルールをファクトと呼び，
$\leftarrow$を省略して表すことが出来る． 
ヘッドが空のルールを一貫性制約と呼ぶ．

ASP 言語には，組合せ問題を解くために便利な拡張構文が用意されている．
その一例として，選択子や個数制約がある． 
選択子は\(\{a_1;\dots;a_n\}\)のように表され，
アトム集合\(\{a_1,\dots,a_n\}\)の任意の部分集合を表現することが出来る．
選択子の両端に選択可能な個数の上下限を付けることで，
任意の部分集合を表していた選択子ではなく，
アトムの個数が上下限内に収まるような部分集合を表す個数制約となる．
また，組合せ最適化問題を解くための最小化関数
(\code{#minimize})や最大化関数(\code{#maximize})も存在する．
最小化，および最大化したい目的関数は複数記述することが可能であり，
それぞれに優先度を付けることで優先度の高い目的関数から最適化探索を
行うようにすることも可能である．

ASP システムは，与えられた論理プログラムから，
安定モデル意味論に基づく解集合を計算するシステムである．
近年では，
{\clingo}~\footnote{\url{https://potassco.org/}}，
{\dlv}~\footnote{\url{http://www.dlvsystem.com/dlv/}}，
{\wasp}~\footnote{\url{https://www.mat.unical.it/ricca/wasp/}}
など，SAT ソルバー技術を応用した高速な ASP システムが開発されている．
なかでも{\clingo}は，高性能かつ高機能な ASP システムとして
世界中で広く使われている．

次に，解集合の定義について簡単に説明する．
論理プログラム$P$について考える．
そして以下に示すような表記を導入する．
\begin{itemize}
\item $\head{r}$ はルール$r$のヘッドを表す
\item $\pbody{r}$はルール$r$のボディにあるデフォルトの否定が付いていないアト
ムの集合を表す
\item $\nbody{r}$はデフォルトの否定が付いているアトムの集合を表す
\end{itemize}

論理プログラム$P$のアトム集合$X$に関するリダクト
$\reduct{P}{X}$を以下のように定義する．
\[\reduct{P}{X}
  =
 \{\head{r}\leftarrow\pbody{r} \mid r\in P, \nbody{r}\cap X=\emptyset\}\]
この時，アトム集合$X$が$\reduct{P}{X}$の最小モデルであるならば，
$X$が$P$の解集合となる．

解集合プログラミングを用いた問題解法のプロセスは，以下の手順からなる． 
まず最初に，解きたい問題を論理プログラムとして表現する．
次に， ASP システムを用いて，論理プログラムの解集合を計算する．
最後に，解集合を解釈して元の問題の解を得る．
%

LNPS の実装には ASP システムとしては{\clingo}を用いた. 
以下では，
{\clingo}に存在する機能の一つで，
求解における変数選択ヒューリスティクスの変更を, 
プログラム上から行う機能について説明を行う. 
以降で示す論理プログラムのソースコードはすべて{\gringo}言語で書かれて
おり, 論理プログラムの説明で用いた記号のソースコード上での
表記法を表~\ref{tbl:map}に示す. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[htb]
  \centering
  \begin{tabular}{l|*{4}{p{1cm}}}
    論理プログラム &   $\leftarrow$ & $,$        & $;$        & $\sim$       \\\hline
    ソースコード   &   \texttt{:-}  & \texttt{,} & \texttt{;} & \texttt{not}
  \end{tabular}
  \caption{論理プログラムとソースコードにおける記号の対応}
  \label{tbl:map}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

変数選択ヒューリスティクスの変更には，
論理プログラム上で以下のような表記を用いることで行う. 
\begin{displaymath}
\#heuristic \quad A~ : ~Body. ~~~[w,m]
\end{displaymath}

これは, \textit{Body}が成り立つ時, アトム $A$ の変数ヒューリスティクスを重み
 $w$ と指定子 $m$ に従って変更することを表している. 

変数選択ヒューリスティクスをどのように変更するかは，
指定子によって決定される．
指定子として $true$ と $false$ を例にとり説明をする．
$true$ はアトムに優先的に真を割り当てるようにする指定子で，
$false$ はアトムに優先的に偽を割り当てるようにする指定子である．

コード\ref{code:heu.lp}は, \#\textit{heuristic}ルールを用いた
論理プログラムの例である．
１ 行目には拡張構文である選択子が使用されており，
アトム$a$,$b$は真でも偽でも良いということを表している. 
２ 行目は一貫性制約を用いて，
アトム$a$,$b$が同時に真になることを禁止している．
3,4 行目はそれぞれ$a$,$b$に関する
\#\textit{heuristic}ルールであり，
3 行目は, 優先度１で$a$に真を割り当てることを，
4 行目は, 優先度２で$b$に真を割り当てることを表している．
各アトムのデフォルトのレベルは０であり，
最もレベルの高いアトムから真もしくは偽が割り当てられる．

コード\ref{code:heu.log}に{\clingo}の実行例を示す．
{\clingo}では ``--heu=domain" をオプションとして指定することで，
\#\textit{heuristic}ルールが有効となる．
この実行では，
アトム$b$のみが真となった解が出力されている．
$a$に関しても真を優先的に割り当てるようなルールが記述されているが，
$a$に対するルールが優先度１であるのに対し，
$b$に対するルールは優先度２であるので，
まず$b$に優先して真が割り当てられる．
その後，
一貫性制約によって$a$,$b$が同時に真になることは
禁止されているために
$a$に偽が割り当てられ，
その結果が出力されている．
また，コード\ref{code:heu.lp}で２行目の一貫性制約の記述が無ければ，
$a$,$b$どちらの\#\textit{heuristic}ルールも有効となって，
実行結果は$a$,$b$の両方を含む解が出力されることになる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstinputlisting[float=t,caption={%
変数選択ヒューリスティクスの例 (\code{heu.lp})},%
captionpos=b,frame=single,label=code:heu.lp,%
numbers=left,%
breaklines=true,%
columns=fullflexible,keepspaces=true,%
basicstyle=\ttfamily\scriptsize]{code/heu.lp}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstinputlisting[float=t,caption={%
\code{heu.lp} に対する\textit{clingo}の実行例},%
captionpos=b,frame=single,label=code:heu.log,%
numbers=left,%
breaklines=true,%
columns=fullflexible,keepspaces=true,%
basicstyle=\ttfamily\scriptsize]{code/heu.log}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{LNPS の実装}
LNPS の実装にはプログラミング言語 Python を用い，
実行には {\clingo} の Python インターフェースを利用する．
最適化を行う任意の ASP プログラムに適用して，LNPS による探索を可能にするシステムを実現した．
ASP システムに対し，任意の問題を解く為の ASP プログラムと Python で記述された LNPS プログラムを
与えることで，問題の解を得られるという仕組みになっている．

実際にどのような動作が行われているかを順を追って説明する．
まず既存 ASP 解法によって問題を解き，
ある探索中断基準に基づいて探索を中断し，暫定解を得る．
得た暫定解に対して，destroy 演算によって値割り当ての一部を取り消す．
取り消されなかった値割り当てに対して，
次回探索開始時に優先的に真となるように
\#\textit{heuristic}ルールを生成する．
ルールを有効にした状態で re-search による再探索を行う．
これにより，値割り当てをなるべく維持したままの再探索が実現され，
再度ある基準で再探索を中断，値割り当てを取り消すという動作を繰り返す．

\subsection{destroy 演算の実装}
LNPS では，
暫定解のどの値割り当てを取り消すかに依存しすぎない探索を行うことが可能であると
述べたが，
それでも LNPS の性能には，
適切な destroy 演算を設計する必要がある．
今回実装した複数の destroy 演算の説明をするにあたって，
解く問題の性質を利用したものもあるため，
まず簡単に今回使用した問題である時間割問題について述べる．

本研究で対象とした時間割問題は，
カリキュラムベース・コース時間割問題で，
時間割問題の中でも最も研究が盛んな時間割問題の一つである．
カリキュラムベース・コース時間割は
必ず満たすべきハード制約と，
できるだけ満たしたい重み付きソフト制約から構成され，
違反する制約の重み（ペナルティ）の最小化が目的である．
ハード制約を満たしながら与えられた講義をそれぞれの日時と教室に割り当て，
「受講者数が，教室の収容人数を超えた分だけペナルティが与えられる」などといった
ソフト制約によって目的関数の値が決まる．\\

次に実装した 4 種類の destroy 演算について説明を行う．
    \begin{enumerate}
    \item random $N$\\
       暫定解の値割り当ての中からランダムに$N$\% を選んで取り消す．
       $N$ として０も選択可能であり，その場合，
       解を取り消さずに暫定解の全ての値割り当てに対して優先度を上げる．
       そのため，
       暫定解の値割り当てに近い値割り当ての解への探索を促進させることが狙いとなる．
       値割り当てをある程度の割合で取り消す場合は，
       暫定解の近辺を探索しながら，
       局所的最適解に陥らないようにさせることを狙いとしている．
    \item day-period\\
      ランダムに曜日と時限をそれぞれ一つ選択し，
      選択した曜日の選択した時限に割り当てられている値割り当てを全て取り消す．
      この destroy 演算は，
      割り当てられる教室の変更を促進させ，
      教室に関するソフト制約へのペナルティを改善することを狙いとしている．
  \item day-room\\
   ランダムに曜日と教室をそれぞれ一つ選択し，
   選択した曜日の選択した教室に割り当てられている値割り当てを全て取り消す．
   この destroy 演算は，
   割り当てられる時限の変更を促進させ，
   時限に関する制約へのペナルティを改善することを狙いとしている．
  \item swap-room $N$\\
    暫定解からランダムに$N$\%の値割り当てを選び，
    曜日と時限はそのままで，割り当てられている教室の情報を取り消す．
   この destroy 演算は，
   day-room と比較して割り当てられる教室のみの変更を促進させ，
   より教室に関するソフト制約へのペナルティを改善することを狙いとしている．
    
  \end{enumerate}