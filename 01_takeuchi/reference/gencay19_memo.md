#### Applications of non-monotonic reasoning to automotive product configuration using answer set programming

関連研究には，ASPを用いた非単調推論の自動車製品構成への応用[Gencay 19]がある．この研究では，工業規模の自動車の製品構成問題に対して，ASPを利用した製品構成ドキュメントの検証や，常に使用されるオプションの発見などの応用を行い，標準的な性能の計算機で最先端のASPソルバーを使用し，数秒単位の計算時間で計算が可能であることを確認している．

本研究の相違点は，CAFE方式に基づく燃費制約を用いていること，制約の矛盾の検証ではなく，目的関数に応じた装備仕様の探索を行っていることが挙げられる．

## Abstract

自動車工業では，製品構成データの検証とメンテナンスは複雑なタスクだ．顧客からの注文と研究開発部からの新たなプロダクトラインのデザインはどちらも満たすべき設定ルールの集合に従うことになる．この研究では，非単調な計算論理，特にASPを工業規模の自動車の製品構成問題に適用する．この方法論は，製品構成文書の基本的な検証と，単一製品の注文の検証を提供し，Reiter式診断では，無効な注文や製品構成ルールの集合を修正するために必要な最小限の変更を提供する．加えて，密接な関係にある製品構成の変数(可変点)のグループを見つけるための方法は，基本的な論理プログラムの小さな修正と慎重かつ勇敢な推論法によって得ることができる．結果として，すべての設定で使用されるオプション，あるいは設定なしでも使用されるオプションは簡単に特定でき、常に一緒に使用されているオプションのグループ、あるいは全く一緒に使用されていないオプションのグループも同様だ．最後に，あらかじめ選択されたオプションの集合に含まれているか除外されているいるかに関連して，必須オプションと廃止オプションを選択することができる．工業用データセットでの実験結果は適用可能性を示し，結果の例で，標準的な計算機で最先端のASPソルバーを使用して数秒単位の計算時間で計算が可能であることを確認した．

#### まとめると？

- 課題

  - 自動車の構成データが正しいか検証するのはめちゃむずい

- 研究で扱う問題

  - ASPを工業レベルで自動車の構成問題に適用

- 研究成果

  - 製品構成データの基本的な検証，単一製品の注文の検証を提供
  - Reiter式診断で矛盾を解消する最小限の変更を提供
  - 常に使われるオプション，常に一緒に使われるオプション，絶対一緒に使われないオプションを特定できる
  - 必須オプションと廃止オプションを選択できる

- 実験結果

  - 工業用データセットで適用可能性を示した
  - 普通のPCで最先端のASPソルバーを使用して数秒単位で計算可能であることを示した

  

### Keywords

- 製品構成
- 非単調論理
- ASP
- 自動車製造
- 構成管理
- マスカスタマイゼーション



## Introduction

### 研究背景

### 研究のモチベーションと研究内容

構成のルールを修正した後，構成ルール集合は矛盾していないかどうかの検証されなければならず，かつ新たなルールによるその他の潜在的な望まない効果を分析しなければならない．潜在的な解空間は膨大であるため，明示的な列挙を用いてチェックすることは不可能である．ルールセットを検証するだけでなく，構成空間の中から有意なパターンを見つけ出し，ルールセットの変更による潜在的な有害な影響を予測することは，困難な作業だ．

本研究では，これらへの挑戦をモチベーションに，工業規模の構成ルール集合の検証と分析のための新たな手法を提示する．本手法は宣言的知識表現パラダイムとして知られるASPをベースにする．個々で紹介するアプローチでは，ルノーのベンチマーク構成ルールをベンチマーク構成空間のセマンティックスを再現するASPプログラムに変換し，この変換の正しさを証明する(符号化は同様の構成インスタンスにも適用可能である)．

不整合が生じる場合，ルール集合の中の不整合の原因を診断する必要し，それを修復できるように(充足するように)する必要がある．普通，最小の変更による修復を目標とする．潜在的な不整合の原因を見つけるために，Reiter 式診断(Reiter 1987)は，ASPによる診断に関する先行研究（Balduccini and Gelfond 2003; Eiter et al.1999）と，認知ロボティクス（Erdem et al.2012）や知識統合（Eiter et al.2014）のような多様な分野におけるASP診断の応用に基づいて，ASPルールで実現されている．

常に使用される，あるいはまったく使用されないオプションを特定するために，以下で説明する手法は，これらのすべてのバリアントを明示的に列挙することなく，すべての構成可能な車のバリアントにわたって常に真（または偽）であるそれらのパラメータを解集合から取得することを可能にする特定のASPクエリモード（勇敢で慎重な推論）を利用している．この分析は，次の通り有用だ：

- 使用されない部品を発見すれば，陳腐化したオプションに属する部品を生産性の高い倉庫から取り除くことができ，管理および保管関連のコストを削減することができる．
- 必須部品は，処理時間短縮とコスト削減のために，製品構成管理システム，ERPシステム，ストレージ管理，生産計画などで必須であると考慮される必要がある．



さらに，提案手法は構成空間の構造をより詳細に調べることを可能にする．すなわち，常に一緒に使用されるオプションのグループを見つける識別である．このようなグループに属するオプションが使用されていない場合，グループ内の他のオプションもまた構成可能な車のバリアントに含めることができない．この分析結果は，生産環境での製造の流れをより効率的にアレンジするために使用でき，実際にルノーのベンチマークにはそのようなオプショングループの例がいくつか含まれている．

最後に，プリセットされた構成パラメータの集合に関する構成空間について上記すべての推論を適用することができる．これは，特定の国のみを対象とした構成空間の分析や，特定のエンジンタイプ，またはその組み合わせを除外した構成空間の分析に有用である．



### 実験

標準的なPCハードウェア上でのルノーのベンチマークを用いた実験は，ASPが実世界の工業規模の自動車構成問題に適用可能であることを示し，アプリケーションの一部を，手元の構成ルール集合の整合性やその他の特性について即座にフィードバックできるインタラクティブなユーザインタフェースに統合することさえ可能である．



### 論文の構成

- Preliminaries
  - 製品構成ルール集合
  - ルノーベンチマーク
  - ASPの短い概説
- Literature survey
  - 関連研究の説明
- Representation of industrial configuration in ASP
  - 構成問題をASPの形式へ変換
  - この表現の正しさを証明
- Applications
  - この表現に基づくいくつかのアプリケーションの紹介
    - 単一オーダー構成の検証
    - 構成問題を不整合にするルールの発見
    - 常に真あるいは常に偽となる構成設定の特定
    - 常に一緒に使用される(または全く使用されない)部品/設定のグループの発見
    - 最終的に事前に選択されたパラメータ値のセットに関連したこれらすべての問い合わせ)
- Results and discussion
  - ルノーベンチマークでのパフォーマンステスト
- Conclusion and Future directions
  - 本研究の結論と今後の方向性



## Preliminaries

### Industrial-scale configuration benchmark

- 本研究で使用される構成ルールセットは Amilhastreらによる関連研究(2002)から由来する．
  - 元々，そのルールセットはフランスのルノーDVI車メーカーから提供されている ．
  - ルールセットは，ルノー メガーヌのファミリーカーの構成を規定しています．
  - ファイルには，可変要素，可変要素のドメイン，可変要素の組み合わせのルールなどの情報が記載されている
  - 可変要素は、エンジンの種類、車が製造される国、エアコンの種類など、車のさまざまな構成オプションを表しています．
  - 構成ルールセットはCLib Configuration Benchmarks Library(2004)の異なるフォーマットで利用できる．
  - 本研究はプレゼンの都合上CP format syntax(2004)を使う．
- 製品文書は変数 V={v1,...,vn} の集合から構成され，各変数viはドメイン定義Di={di1,...,dim}をもち，さらにルール集合R={r1,...,rk}がある
  - Vはタイプの集合，Dはオプションの集合，ルールは依存制約
- 以下はCP形式のルールの例である



- ルールは，変数割り当ての連言の選言を構成する．

  - よって，変数の割り当てが命題，より正確には正リテラルとして解釈されるならば，各ルールは選言標準形(DNF)である．
  - すべてのルールはともに満たされなければならないので，満たすべき論理式はDNF式の連言である．
- 変数割り当ての連言は以降最小項(minterms)と呼ぶ．
    - minterm: var3==M5 && var5==FRAN && var6==DG

- k個のルールを含む製品の文書を定式化するルールの集合の論理式は次のように定式化される．

  - $\Phi = \and r_l$
  - この形式のルールは $v_i == d_{i_j}$ を表すリテラルの連言の選言である

- ルノーのベンチマークは次のような内容だ

  - ドメインサイズ(各タイプのオプション数)が2から43の範囲である101の変数(装備タイプ)と113のルール
  - 問題の解の数はおよそ$1.4\times 10^{12}$
  - CP形式のルールセットはコード195,500行からなる23.9MBの容量をもつ



### Anwer set programming

省略



## Literature survey

製品構成の調査は1970年代の終盤まで遡り，まだ積極的に調査されている分野である．製品構成の定義やモデルからなる理論と，製品構成ソフトウェアシステムの形での現場での実践の両方で多くの研究がある．Sabinらの製品構成機(コンフィギュレータ)は，ルールベース，モデルベース，ケースベースのアプローチに分類することができる．

ルールベースのコンフィギュレータは，有効な製品構成を生成するために「IF 条件 THEN 結果」の形でルールを実行するエキスパートなシステムとして開発されてきた．... ...

モデルベースの知識表現技術は初期のルールベースのコンフィギュレータのこれらの欠点に対処するための解決策として登場した．... ...

ケースベースの推論は，以前に解決した類似の問題を見つけ，その解決策を新しい問題の要件に適合することで，新しい構成問題を解決しようとする．... ...

これらの主なカテゴリーとは別に，製品構成問題に対するまったく異なるアプローチもまた存在する．Kusiakらは，企業内で利用可能な大量の販売データを分析し，企業資源の有効性を高めることができる製品構成を特定するデータマイニング手法としてクラスタリングを適用している．



## Representation of industrial configuration in ASP

"Industrial-scale configuration benchmark"の節で，製品構成ルール集合の定式化が与えられた．この節では，定式化からASPプログラムへの変換が記述され，この変換がオリジナルの構成問題のセマンティックスを表現することの証明を与える．

変換は，以下のように行われる．

1. すべての $v_i == d_{i_j}$ の形式の変数と値の比較を，$v_i$ _ $d_{i_j}$ の形式の単一リテラルに変換する

   - 「タイプ$v_i$ のオプションは $d_{i_j}$ である」

2. $(p_1 \land p_2 \land \dots \land p_{n-1} \land p_n)$ の形式のすべてのルールのすべての最小項を$ t=1,\dots,z$ で数え，各最小項に対してASPルールを次の形式で作成する．

   $c_t \leftarrow p_1,p_2, \dots, p_{n-1},p_n .$  		(2)

   - $p_1,...,p_n$ すべて成り立つならばminterm $c_t$ が成立する

3. 1つのルールに含まれる最小項 $k = l, \dots, m$ に対して，次のASP制約を定義する．

   $\leftarrow not\ c_l, not\ c_{l+1},\dots , not\ c_{m-1}, not \ c_m .$  		(3)

   - minterm $c_l,...,c_m$ のうち少なくとも1つは成り立つ

4. ドメインが ${d_{i_1},\dots,d_{i_u}}$ である各変数 $v_i \in V$ に対して，ASPの選択ルールを以下のように定義する．

   $1\{v_i \_ d_{i_1};v_i \_ d_{i_2};\dots;v_i \_ d_{i_u}\}1 \leftarrow .$ 		(4)

   - タイプ $v_i$ のオプションはちょうど1つが選択される

直感的に，手順2でminterm $t$ の真理値はアトム $c_t$ によって表現される．手順3ではルールに違反する解がないことを確認し，手順4では各変数 $v_i$ に対してちょうど1つのドメイン要素の割り当てとして潜在的な解を定義する．



##### Example 1

CP形式でのルノー製品文書のルールの一部は以下のようである．

・・・

手順1,2は次のようになる．

・・・

はじめのCP形式のルールは，$c_{208}$ から $c_{307}$ までのヘッドを用いてASPのルールに変えられる(この例で，207のmintermはこのルールの変換前に生成されている)



手順3はCPルールのmintermで示される変数のうち少なくとも1つが真であることを指定するような，次のASP制約を導入する．

​	$\leftarrow not\ c_{208}, not\ c_{209},...,not\ c_{371}.$

この手順の後，CP形式のルールと同じ数の制約が生成される．



手順4は，直感的に各変数についてちょうど1つのドメインを選択するような次の選択ルールを生成する．

​	・・・



解集合に対する具体例はApplicationsの節で与えられる．



上のルールによる構成問題の表現の正しさを以下で示す．

構成ルール集合に関して任用される構成問題と結果的な構成に対する形式的な定義は次のとおりである．(これらはPreliminariesの節で直感的に示す)



##### Definition 1

##### Definition 2

##### Definiton 3

##### Proposition 1



## Applications

与えられた生産オーダーの検証や完全な製品ドキュメントの検証，例えば構成ルールベースの検証のような基本的な基本的なアプリケーション以外にも，生産計画や倉庫管理に関連する一連のアプリケーションがある．以下では，ASP でのアプリケーションとその実装についての詳細を説明する．

構成制約の主要な目的は，実行可能な構成が何か決定することである．したがって，ルール集合に対して与えられた構成を検証することが，構成インスタンスのASP符号化の最初の使用法である．

特定のオーダーの構成を検証するために，このオーダーの内容はボディなしのルール，すなわちファクトとして表現される．その後，このルール集合は製品ドキュメントを表現する解集合プログラムに加えられる．この新しいプログラムの解集合の列挙によって有効な構成が得られるか，もし構成がむじゅんしていたら解なしが得られる．

オーダーは，$p_{ij}=u_i\_d_{i_j}$ の形式の鍵となる値のペアを示すリテラルの集合を用いて定式化できる：

​	$o = \{p_{ij} | i \in \{1,2,\dots,|V|\}, j \in \{1,2,\dots, |D_i|\}\}$

製品ドキュメントを表すASPプログラムは，これらのリテラルそれぞれを単一のファクトとしてオーダー集合にに追加することで補完することができる．$z$ 個のファクトを用いたオーダーの定式化は次のように表現できる：

​	$p_1.p_2.\ \dots \ p_{z-1}.p_z.$

例えば，スイスでのすべてのディーゼル車のモデルは，次の構成がある

​	var5=SUIS var4=DIESEL

これは次のようなアトムによってASPの形式で表現される

​	var5_SUIS var4_DIESEL



変換された製品ドキュメントとそのようなファクトを構成するASPプログラムは，現在，充足可能性をチェックすることができる．オーダーの中で，Vのすべての変数がリテラルを通して集合に入れられる必要はないことに注意されたい．オーダーでは変数のいくつかは未定なままにすることができる．この場合，ソルバーによって算出される解集合は，未定な変数に対する割り当てを用いて1つの可能性のある実行可能解として解釈できる．

以下で説明するアプリケーションは，単一の構成を検証するだけではない：以下の符号化は，最新の計算技術とASPソルバーの力を使って，すべての可能性のある構成を一度に分析する．

#### Diagnosis(APP1)

車のオーダー構成に誤りがあった場合や、製品ドキュメントが無効な場合，普通はどのルールあるいはルールの部分がテストを失敗させる原因になっているのか知りたいと思う．無効な構成を再度有効にする方法は複数あるので，そのための変数設定の変更の，最小値を求めることも望ましい．これを達成するために，ASPは，Reiterによる第一原理からの診断の理論に従って，異常を示す追加の変数によって補完される．

CP形式からASPへの変換の手順3で，各ルールのmintermに対する制約は定義される．mintermを示す負リテラルに加えて，ここで制約の異常を表すために各制約に変数をつける．

​	$\leftarrow not\ c_l, not\ c_{l+1},\dots, not\ c_{m-1},not\ c_m,ab(i,1).$

上の例に従って，制約のいくつかをこの方法で以下のように生成する．

・・・

述語 $ab$ は2つの引数をもつ．1つ目の引数は，負リテラル $not\ c_l,\cdots,not\ c_m$で示されるmintermを含むルールの実行番号を保持する．2つ目の引数は，異常の重さを与える．すべてのルールで一様な重み1を選択したが，第2引数の値として，各項の異なる変数の数を変更したり，生産に対するルールの重要性の優先度を選択することができる．

ASPでは，制約は，プログラムで指定されたとおりに，変数を縛ることによって生成されたアトムを閉じ込めるためにのみ定義することができる．述語 $ab$ の使用を可能にするために，次のASPルールはすべての可能性のある異常の組み合わせを生成する．

​	$\{ab(1,1);ab(2,1);\dots;ab(n,1)\}.$

ルノーベンチマークは113のルールを含むため，次のようなルールが得られると推測される．

​	$\{ab(1, 1); ab(2, 1);\dots; ab(113, 1)\}.$

ルールの両側に制限数がないので，リテラル $ab(1,1),\dots,ab(n,1)$ の任意の部分集合が真であると推測することができる．この修正(追加)により，元の制約がこれらのリテラル $ab(・,・)$　のおかげで無効化されるため，新たな解集合プログラムは常に充足されることが保証される．

結果として，異常リテラルの数は解集合の中で矛盾する構成ルール集合に対するUNSATを出力する代わりに現れる．次のステップとして，最小化文は，違反したルールの数が最小である解集合以外すべてを排除する．

多くのASPソルバーで，#maximize と #minimize の表現とリテラルへの重み割り当てが使用できる．各解集合に対して，リテラルの重みを足し合わせた合計が計算される．次の文では，解を最小のものに制限している．

​	$\#minimize\{C@1,X : ab(X,C)\}.$

ここで，引数Cは，すべての異常リテラルの重み和のような最小化するコストを示す．... ...

この最適化制約を使用することで，最適な解集合のコストは，コスト1が各ルールの重みとして指定されていたため，違反したルールの数に対応する．

ルノーベンチマークは一貫性がある(整合している)ため，ASPの定式化を適用すると空集合が得られる．したがって，一貫性のある製品ドキュメントを得るために制約を解除する必要はない．より興味深い結果をもたらすケースとしては，「すべての構成で使用される/どの構成でも使用されないオプション」の節で議論される，事前に選択されたオプションの集合に関するこの定式化の使用法である．



### APP2

多くのASPソルバーは論理プログラムのbrave かcautiousな結果を計算できる．論理プログラムのbraveな結果はいくつかの解集合のなかの真であるアトムであるのに対して，cautiousな結果はすべての解集合で真であるアトムだ．言い換えると，プログラムのすべての解集合の好転はcautiousな結果を表し，プログラムのすべての解集合の和はbraveな結果を表す．

これらの定義が与えられれば，論理プログラムのcautiousな結果がすべての車種で使用される正確なオプションの集合を表すことは明らかだ．この方法は，ルノーベンチマークのすべての構成可能な車種に存在する次の7個のオプションを特定する：

​	var71=FSTPO var50=SASURV ...



このアプリケーションに対するASPソルバーclingoの具体的な出力は次のようである．

​	var71_FSTPO var50_SASURV ... ...



どの車種でも使用されないオプションを発見するために異なる方法がいくつかある．その1つは，プログラムbraveな結果を計算し，構成オプションを表すすべてのアトム集合の違いを見つけることだ．結果の集合は明らかにどの構成可能な車種でも使用されないオプションになるだろう．clingoと論理プログラムをそのまま使用すると(使用した実験セットアップの詳細は節「結果と議論」参照)，braveな結果の計算には2時間36分かかる．その結果はオプションを表現しているアトムだけでなく，CP形式の各ルールのmintermを表すアトムも含む．したがって，結果の集合は#show宣言を使用して最初のものに限られる．#show宣言は結果として得られる解集合の特定の述語のアトムを選択的に含むことができる．論理プログラムをオプションを表すアトムを#show宣言で補完した後，clingoはプログラムのbraveな結果を計算するのに約10秒かかる．

これらのオプションを発見するもう一つの方法は，はじめにすべてのオプション変数のデフォルトの否定として新しい変数を定義し，変数の否定に対するルールによって補完されたプログラムのcautiousな結果を計算する方法だ．変数の否定に対する定義の例は下で与えられる：

​	$nval_B64 \leftarrow not\ val1\_B64.$

これらの否定とcautiousな推論を使用すると，ASPソルバーclingoの具体的な出力は次のようである．

​	nvar8_CPLG nvar10_temp nvar17_temp nvar24_temp



ここから，どの構成可能な車種でもまったく使用されない次のようなオプションが得られる

​	var8=CPLG var10=temp 

 「temp」という言葉は，これらのオプションのバリエーションがある種の一時的な場所の保持者を表していることを示しているため，これらのオプションの多くは偽陽性であるように思われる．

どの製品構成でも使用されないオプションの発見によって，これらの部品は，例えばスペアパーツとして供給するために生産倉庫から解放されるようになるので，特定されたオプションによって影響を受ける部品に関連する製品倉庫管理，在庫管理，製品管理，人件費節約が可能になる．

言い換えると，オプションが，本当に潜在的な製品構成で必要なオプションである時(例えば，偽陽性の場合)，顧客がこれらのオプションを含む製品に興味を持った時，それらのオプションが発見されることで機会損失の可能性を防ぐ事ができる．



### APP3

上の符号化に基づいて，構成空間について追加の情報が得られる：構成で常に一緒に使用される，あるいは常に一緒に存在しないオプションの組やグループ．

そのような情報を得るために，前述の定式化は次のルールによって拡張される．

​	$pair_{v_i\_d_{i_j},v_k\_d_{k_l}} \leftarrow v_i\_d_{i_j},v_k\_d_{k_l}.$
​	$pair_{v_i\_d_{i_j},v_k\_d_{k_l}} \leftarrow not\ v_i\_d_{i_j},not\ v_k\_d_{k_l}.$

​		$for i,k \in \{1,\dots,|V|\}, j \in \{1,\dots,|D_i|\}, and l \in \{1,\dots,|D_k|\}$



これは新しいアトム $pair_{v_i\_d_{i_j},v_k\_d_{k_l}} $ を定義する．このアトムは次の2つのケースで真になる：変数$v_i$ が値$d_{i_j}$をとり，かつ，変数 $v_k$ が値 $d_{k_l}$をとるとき，あるいは2つの変数がどちらもこれらの値をとらないとき．この変数/値の組み合わせが解の中で等価真理値をもつ(どちらも真あるいはどちらも偽である)とき，本質的にこの新しい変数は真だ．

結果として得られるASPプログラムでcautiousな推論を実行することで，構成で常に「同期」されている変数/値の組み合わせのすべてのペアが得られる：両方の変数が指定された値を持っているか，または両方ともこれらの値を持っていないかのどちらかだ．これらの観察は，自動車製造のドメインに戻って翻訳され，自動車の中で常に一緒に使用されているか、全く使用されていないかのいずれかのコンポーネント（または他の変数設定）のセットを提供します。

一緒に使用されるコンポーネントのペアから，そのようなコンポーネントのグループが計算される：もしコンポーネントAとBが常に一緒に使用され，かつコンポーネントBとCも一緒に使用されるとき，AとCもまた一緒に使用される(構成要素は数学的に等価クラスを形成する)．

このcautiousな計算の実行は常に一緒に使用される，あるいは，まったく一緒に使用されない29の等価なコンポーネントの関係をもたらす．このうち，どの構成でも使用されないアイテムのグループとすべての構成で使用されるアイテムのグループの2つは些細なグループだ．

常に一緒に使用される，あるいはまったく一緒に使用されないアイテムの些細でないグループの例は，次の3つのグループだ．

​	{var3=ME, var100=CRIT764, var75=MOCY02}

​	...

​	...

例として，最初のグループはcautiousな解集合のなかで次のアトムによって示される．

​	pair_var3_ME_var75_MOCY02

​	pair_var3_ME_var100_CRIT764

​	pair_var75_MOCY02_var3_ME

​	... ...

実際には，そのような情報は，組立時の輸送距離や物流の労力を最小限に抑えるために，保管スペースを配置するための貴重な情報となる．この情報のもう一つの使い方は，そのようなグループ内のオプションはおそらく常に一緒に使用されるため，1つのオプションに単一化するための検討ができる．このようにして，構成プロセスの効率を高めることができる．

### APP4

構成空間の制限によって，例えば，あるオプションの使用を強制したり，別のオプションの使用を禁止することによって，アプリケーションシナリオAPP1-APP3は，構成空間の仮想的な変更に相対的に適用することができる．

例えば，あるオプションが使用されるべきである、または使用できなくなったという仮定の下で、どのオプションが必須であるか、または廃止されたか（APP1）を計算することができます。

そのような推論は上のアプリケーションのASP符号化に制約を加えることによって達成される．これらの制約はある変数/値の組み合わせやそれらの禁止を要求する．

変数iが値jを得ることを要求するために，それぞれのアプリケーションにhいつ様な要求は次の制約を加えることだけだ．

​	$\leftarrow not v_i\_d_{i_j}.$

直感的に，これは，$v_i\_d_{i_j}$が偽であるという解を無効と宣言し，言い換えれば，すべての解集合で$v_i = d_{i_j}$ という条件が充足されることを宣言する．

変数$v_i$ が値$d_{i_j}$を取らないことを要求するには，次の制約を加えることで十分だ．

​	$\leftarrow u_i\_d{i_j}.$

さらに，複数の変数/値の組み合わせはそれぞれの制約を加えることで，同時にこのように制限される．

ルノールールセットでは，制約 $\leftarrow not\ var5\_SUIS$ が加えられれば，これはバリエーション$var5\_SUIS が真になることを要求する．cautiousな問い合わせは本来の等価関係とは異なる同値関係の集合をもたらす，例えば，スイスの車のモデルですべての潜在的な構成一緒に使用されるあるいは一緒に使用されないオプションの集合．

この「スイスに関する」問い合わせの結果，18のオリジナルの等価なクラスが得られる．例えば，{var3=ME, var100=CRIT64, var75=MOCY02}はまだ解の一部だ．加えて，次のような従来は存在しなかった同値関係が明らかになる．

{var1=E64, var42=SSPHAN}

さらに，他のすべての国固有の同等性(例えば，var5=ALLE, var82=NMAS03, var72=PAPALL)は，パラメータの「常に偽」のセットの一部になる．

合計すると，car5_SUISを制限すると，制限されていない製品バリエーションの集合に対して，17個の構成パラメータは常に真になり，75のパラメータは常に偽になる．

例えば，次の制約を使用することで，ディーゼルエンジンの除外によって構成空間はさらに制限される，

$\leftarrow var4\_DIESEL.$

結果として，さらに新しい同期構成パラメータが明らかになる．上の例では，次の新しい同値クラスは解集合から取り出される(そのような解集合のアトムの具体的な例は，「常に一緒に使用されるオプションのグループ(APP3)」から与えられる)．

{var3=MM, var100=CRIT622}

... ...

これらは，var3の選択が完全にcar100の選択を決定することが明らかになる2つの同値クラスであり，これはディーゼルまたは非スイスのバリエーションのケースではない．

さらに，ディーゼルなしのスイスでは，追加の41個の構成パラメータは恒久的に偽になり，2つのパラメータ(var26=SANCL, var4_ESS)は恒久的に真になる．

ペア発見ルールとともに，このASP推論モードは，構成と製造の最適化するための有益な情報を生み出し，個々で説明した方法を使用して，この情報を製品構成ルールセットから非複雑な方法で取得できる．例えば，販売市場に基づいて残りのオプションを分析する(すなわち，国のオプションが事前に選択されている)ことで，生産者が提供するすべての製品ラインが特定の国向けにも生産できるかどうかを調べることができる．









## Result and discussion

上記の符号化とルノーベンチマークに基づいて，実験はアプローチの実現可能性の検証のために行われた．

実験環境は... ...

ASPソルバーはClingo



上で述べられたすべてのアプリケーションシナリオの実験結果は表1にまとめられている．特に，行われたすべての実験について，求解時間とメモリー消費が示されている．表の列はそれぞれのアプリケーションセクションを表す．



根底にある問題がNP完全問題であるにもかかわらず，結果は上々である：殆どのアプリケーションシナリオは推論に10秒以下の時間を要している．結果として，このような推論は，製品ドキュメントを編集するためのインタラクティブなツールに統合することができる．特に，バリエーションの選択（APP4）に関する問い合わせは(APP4)は，適度な時間を必要とする．



メモリ消費はAPP1とAPP2で類似しており，APP3とAPP4では少し多く要求される．このことはAPP3とAPP4のみで要求されるプログラム中のペア検出ルールによって説明される．



表1の列APP1は，どのルールがドキュメントの矛盾を引き起こすか発見するような，製品ドキュメント上での診断計算に必要なリソースを示す．列APP2/braveは，少なくとも1つの構成可能な車のバリアントで使用されるオプションを特定することに関連し，APP2/cautiousはすべての構成可能な車のバリアントで使用されているこれらのオプションを計算することについてで，APP2/+negationは，すべての構成可能な車種に含まれないオプションを発見することを意味する，negationによるcautiousな問い合わせついての結果を示す．もっとも時間のかかる計算は，明らかにすべての構成可能な車でどちらのオプションも含まれる，あるいはどちらもふくまれないようなオプションのペアを探索するAPP3である．.......



APP4で，特定のオプションを要求したり禁止したりすることで構成空間が制限されるほど，推論が速くなる．このように制約空間を増やして解きやすくすることは，ASPやSAT，制約解法ではよく知られた現象だ．





## Conclusion and future direction

本研究で，ASPは工業規模の自動車製品構成ルールセットに適用された．構成ルールセットは命題論理式に定式化され，ASP符号化に変形された．この符号化を使用して，自動車製品構成の中で4つのアプリケーションが定義された．このような疑問の調査は，構成可能性の高い製品を生産する物流において，保管や輸送距離を最小化することによって，生産性を向上させ，コストを減らす可能性を秘めている．例えば，どの製品構成でも使用されていないオプションの発見は管理，保管，棚卸し，人件費を抑える可能性があるだろうし，オプションが本当に使用されるべきオプションであった場合（偽陽性の場合），その発見は，可能性のある機会損失の防止のような肯定的な結果をもたらすでしょう．

最初のアプリケーション(APP1)では，Reiterによる第一原理からの診断理論を適用して，設定ルールセットの矛盾の可能性を説明しました．ASPの最小化メカニズムと組み合わせることで，より適切な修復提案を得ることができる．2つ目のアプリケーション(APP2)では，すべての車種で現れる(あるいはまったく現れない)必須オプションや廃れたオプションが算出される．3つ目のアプリケーション(APP3)はすべての構成可能な車のバリエーションにおいて、どのペアまたはグループのオプションが使用されなければならないか、または一緒に存在しなければならないかを明らかにします。最後に、最後のアプリケーション(APP4)は、特定のオプションのセットが使用されるべきであるか、またはもはや利用できないという仮定の下で、必須または陳腐化したオプションを計算します。実証実験では、非単調推論のアプローチとしてのASPが、実現可能で効率的な方法でこれらのアプリケーションに利用できることが示された。

本論文の現在の研究は2つの方向性で拡張される可能性がある．確率的帰納的論理プログラミングの方法は，与えられた解集合プログラムの解集合に対する確率分布を決定するために使用することができる．この情報の分析を通して，製品構成ルールのセットから製品ラインの候補を自動的に発見することができる．もう一つの未来の方向性はASPでの非ブール変数の使用を可能にする技術によって，本論文のアプローチを拡張することだろう．ASPとCSPを組み合わせたClingconのようなハイブリッドソルバーは，すでに使用できる．そのような力を使用して，構成オプションの分析は実数基準に基づく最適化によって拡張される．









